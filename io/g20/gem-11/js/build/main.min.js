"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

(function () {
  //adds common methods and propreties to a given PIXI object
  function addCommonProps(obj) {
    //sets transform of an object
    //optional x, y, scaleX, scaleY, rotation, anchorX, anchorY
    obj.setTransform = function (x, y, scaleX, scaleY, rotation, anchorX, anchorY) {
      if (x != undefined) {
        obj.x = x;
      }

      if (y != undefined) {
        obj.y = y;
      }

      if (scaleX != undefined && scaleY == undefined) {
        scaleX *= obj.defaultScaleX || 1;
        obj.scale.set(scaleX);
      } else if (scaleX != undefined && scaleY != undefined) {
        scaleX *= obj.defaultScaleX || 1;
        scaleY *= obj.defaultScaleY || 1;
        obj.scale.set(scaleX, scaleY);
      }

      if (rotation != undefined) {
        obj.rotation = rotation;
      }

      try {
        if (anchorX != undefined && anchorY == undefined) {
          obj.anchor.set(anchorX);
        } else if (anchorX != undefined && anchorY != undefined) {
          obj.anchor.set(anchorX, anchorY);
        }
      } catch (e) {}
    }; //calculates global transform of an object (position, scale, rotation)


    obj.getGlobalTransform = function () {
      var transform = {};
      var parent = obj.parent;
      transform.position = parent.toGlobal(obj.position);
      transform.scale = {
        x: obj.scale.x / (obj.defaultScaleX || 1),
        y: obj.scale.y / (obj.defaultScaleY || 1)
      };
      transform.rotation = obj.rotation;

      while (parent != null) {
        transform.scale.x *= parent.scale.x;
        transform.scale.y *= parent.scale.y;
        transform.rotation += parent.rotation;
        parent = parent.parent;
      }

      return transform;
    };
  } // Container class - based on PIXI.Container
  //required: parent


  function Container(parent) {
    var t = new PIXI.Container();
    addCommonProps(t);
    t.type = "Container";
    parent.addChild(t); //methods

    t["delete"] = function (deleteChildren) {
      if (deleteChildren == undefined) deleteChildren = true;

      if (deleteChildren) {
        var elLength = t.children.length;

        for (var i = elLength - 1; i >= 0; i--) {
          t.children[i]["delete"]();
        }
      }

      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.toFront = function (child) {
      if (t && child) {
        t.setChildIndex(child, t.children.length - 1);
      }
    };

    t.toBack = function (child) {
      if (t && child) {
        t.setChildIndex(child, 0);
      }
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } // Sprite class - based on PIXI.Sprite
  //required: parent, img;


  function Sprite(parent, img) {
    var t;

    if (PIXI.utils.TextureCache[img] != undefined) {
      t = new PIXI.Sprite(PIXI.utils.TextureCache[img]);
    } else {
      t = new PIXI.Sprite(PIXI.Texture.fromImage(img));
    }

    addCommonProps(t);
    t.type = "Sprite";
    t.anchor.set(0.5);
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.getName = function () {
      return t.type + " - " + t.texture.textureCacheIds[0];
    };

    return t;
  }

  function TilingSprite(parent, img, size) {
    var t;
    var texture;

    if (PIXI.utils.TextureCache[img] != undefined) {
      texture = PIXI.utils.TextureCache[img];
    } else {
      texture = PIXI.Texture.fromImage(img);
    }

    t = new PIXI.extras.TilingSprite(texture, size[0], size[1]);
    addCommonProps(t);
    t.type = "TilingSprite";
    t.anchor.set(0.5);
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.getName = function () {
      return t.type + " - " + t.texture.textureCacheIds[0];
    };

    return t;
  } // Animation class - based on PIXI.extras.AnimatedSprite
  //required: parent, imgPref
  //optional: imgSuf (def: ""), loop (def: false), speed (def: 1);


  function Animation(parent, imgPref, imgSuf, loop, speed) {
    var sprite_frames = [];
    imgSuf = imgSuf || "";
    loop = loop || false;
    speed = speed || 1;
    var i = 0;

    while (true) {
      i++;
      var val = i < 10 ? "0" + i : i;

      try {
        sprite_frames.push(PIXI.Texture.fromFrame(imgPref + val + imgSuf + ".png"));
      } catch (error) {
        break;
      }
    }

    var t = new PIXI.extras.AnimatedSprite(sprite_frames);
    addCommonProps(t);
    t.type = "Animation";
    t.reversed = false;
    t.loop = loop;
    t.animationSpeed = speed;
    t.anchor.set(0.5);
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.revereAnimation = function () {
      t.reverse_prop = !t.reverse_prop;
      t.textures.reverse();
    };

    t.getName = function () {
      return t.type + " - " + t.textures[0].textureCacheIds[0];
    };

    return t;
  } //Spine Animation class - based on PIXI.spine.Spine
  //required: parent, spineData
  //optional: startAnimation, loop (def: false)


  function SpineAnimation(parent, spineData, startAnimation, loop) {
    loop = loop || false;
    var t = new PIXI.spine.Spine(spineData);
    t.skeleton.setToSetupPose();
    t.update(0);

    if (startAnimation != undefined) {
      t.state.setAnimation(0, startAnimation, loop);
    }

    t.type = "Spine Animation";
    addCommonProps(t);
    parent.addChild(t);

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //Threes sprite class
  //required: parent, renderer


  function ThreesSprite(parent, renderer) {
    var texture = PIXI.BaseTexture.fromCanvas(renderer.domElement, PIXI.SCALE_MODES.LINEAR);
    var t = new PIXI.Sprite.from(new PIXI.Texture(texture));
    t.type = "Threes Sprite";
    addCommonProps(t);
    parent.addChild(t);
    t.anchor.set(0.5);

    t.update = function () {
      t.texture.update();
    };

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(true);
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //Text class - based on PIXI.Text
  //required: parrent
  //optional: text (def: ""), textStyle


  function Text(parent, text, textStyle) {
    text = text || "";
    var t = new PIXI.Text(text, textStyle);
    addCommonProps(t);
    t.type = "Text";
    t.anchor.set(0.5);
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(true);
      t = null;
    };

    t.getName = function () {
      return t.type + " - " + t.text;
    };

    return t;
  } //Circle class - based on PIXI.Graphics
  //required: parent, radius
  //optional: lineStyle(def: [0,0,0]), fillStyle (def:[0xFFFFFF,1]), convertToSprite (def: true)


  function Circle(parent, radius, lineStyle, fillStyle, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    lineStyle = lineStyle || [0, 0, 0];
    fillStyle = fillStyle || [0xffffff, 1];
    var g = new PIXI.Graphics();

    if (lineStyle.length > 0) {
      g.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);
    }

    if (fillStyle.length > 0) {
      g.beginFill(fillStyle[0], fillStyle[1]);
    } else {
      g.beginFill();
    }

    g.drawCircle(0, 0, radius);
    g.endFill();

    if (convertToSprite) {
      var t = new PIXI.Sprite(g.generateCanvasTexture(PIXI.settings.SCALE_MODE, 2));
      t.anchor.set(0.5);
      t.type = "Circle Sprite";
    } else {
      var t = g;
      t.type = "Circle Graphics";
    }

    addCommonProps(t);
    t.convertedToSprite = convertToSprite;
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(t.convertedToSprite);
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //CircularSector class - based on PIXI.Graphics
  //required: parent, radius, startAngle, endAngle
  //optional: lineStyle(def: [0,0,0]), fillStyle (def:[0xFFFFFF,1]), convertToSprite (def: true)


  function CircularSector(parent, radius, startAngle, endAngle, lineStyle, fillStyle, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    lineStyle = lineStyle || [0, 0, 0];
    fillStyle = fillStyle || [0xffffff, 1];
    var g = new PIXI.Graphics();

    if (convertToSprite) {
      g.lineStyle(lineStyle[0], 0, 0);
      g.beginFill(0xffffff, 0);
      g.drawCircle(0, 0, radius);
      g.endFill();
    }

    if (lineStyle.length > 0) {
      g.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);
    }

    g.beginFill(fillStyle[0], fillStyle[1]);
    g.moveTo(0, 0);
    g.arc(0, 0, radius, degToRad(startAngle), degToRad(endAngle));
    g.lineTo(0, 0);
    g.endFill();

    if (convertToSprite) {
      var t = new PIXI.Sprite(g.generateCanvasTexture(PIXI.settings.SCALE_MODE, 2));
      t.anchor.set(0.5);
      t.type = "Circular Sector Sprite";
    } else {
      var t = g;
      t.type = "Circular Sector Graphics";
    }

    addCommonProps(t);
    t.convertedToSprite = convertToSprite;
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(t.convertedToSprite);
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //Pie class - based on PIXI.Graphics
  //required: parent, radius, angles(ex: [0,30,90,180,300,360])
  //optional: lineStyle(def: [0,0,0]), colors (def:random color), convertToSprite (def: true)


  function Pie(parent, radius, angles, lineStyle, colors, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    lineStyle = lineStyle || [0, 0, 0];
    colors = colors || [];
    var t = new Container(parent);
    t.sectors = [];

    for (var i = 0; i < angles.length - 1; i++) {
      t.sectors[i] = new CircularSector(t, radius, angles[i], angles[i + 1], lineStyle, [colors[i] || randomColor(), 1], convertToSprite);
    }

    t.convertedToSprite = convertToSprite;

    if (convertToSprite) {
      t.type = "Pie Sprite";
    } else {
      var t = g;
      t.type = "Pie Graphics";
    }

    t.getName = function () {
      return t.type;
    };

    return t;
  } //RadarChart class - based on PIXI.Graphics
  //required: parent, radius, numOfParams
  //optional: numOfSegments (def:2), convertToSprite (def: true)


  function RadarChart(parent, radius, numOfParams, numOfSegments, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    var t = new Container(parent);
    t.convertedToSprite = convertToSprite;

    if (convertToSprite) {
      t.type = "Radar Chart Sprite";
    } else {
      t.type = "Radar Chart Graphics";
    }

    t.numOfParams = numOfParams;
    t.numOfLines = 0;
    t.numOfSegments = numOfSegments || 2;
    t.lines = [];
    t.values = [];
    t.points = []; //circles

    t.circles = [];
    t.circleRadiuses = [];
    t.circleLineStyles = [[5, 0x000000, 1], [2, 0x000000, 0.1]];

    for (var i = 0; i <= t.numOfSegments; i++) {
      t.circleRadiuses[i] = radius * 0 + (t.numOfSegments - i) * radius * 1 / t.numOfSegments;

      if (i == 0) {
        t.circles[i] = new Circle(t, t.circleRadiuses[i], t.circleLineStyles[0], [0xffffff, 1], convertToSprite);
      } else if (i == t.numOfSegments) {
        t.circles[i] = new Circle(t, t.circleRadiuses[i], t.circleLineStyles[0], [0x000000, 1], convertToSprite);
      } else {
        t.circles[i] = new Circle(t, t.circleRadiuses[i], t.circleLineStyles[1], [0xffffff, 1], convertToSprite);
      }
    } //param lines and names


    t.paramLines = new PIXI.Graphics();
    t.paramNames = [];

    if (t.convertedToSprite) {
      t.paramLines.lineStyle(0, 0, 0);
      t.paramLines.beginFill(0xffff00, 0);
      t.paramLines.drawCircle(0, 0, t.circleRadiuses[0]);
      t.paramLines.endFill();
    }

    t.paramLines.lineStyle(t.circleLineStyles[1][0], t.circleLineStyles[1][1], t.circleLineStyles[1][2]);

    for (var i = 0; i < t.numOfParams; i++) {
      var angle = Math.PI + Math.PI * 2 * i / t.numOfParams;
      var x = Math.sin(angle) * radius;
      var y = Math.cos(angle) * radius;
      t.paramLines.moveTo(0, 0);
      t.paramLines.lineTo(x, y);
      t.paramNames[i] = new Text(t);
      x = Math.sin(angle) * (radius + 20);
      y = Math.cos(angle) * (radius + 20);
      t.paramNames[i].position.set(x, y);
      t.paramNames[i].anchor.set(1 - (Math.sin(angle) / 2 + 0.5), 1 - (Math.cos(angle) / 2 + 0.5));
    }

    if (t.convertedToSprite) {
      t.paramLines = new PIXI.Sprite(t.paramLines.generateTexture());
      t.paramLines.anchor.set(0.5);
    }

    t.addChild(t.paramLines);

    t.paramLines["delete"] = function () {
      this.destroy(this.parent.convertedToSprite);
    };

    t.toFront(t.circles[t.numOfSegments]); //methods

    t.drawLine = function (val, style, lineIndex) {
      var style = style || [5, 0x000000, 1];
      if (lineIndex == undefined) lineIndex = t.lines.length;
      var g = new PIXI.Graphics();
      var line = {};

      if (t.convertedToSprite) {
        g.lineStyle(0, 0, 0);
        g.beginFill(0xffff00, 0);
        g.drawCircle(0, 0, t.circleRadiuses[0]);
        g.endFill();
      }

      g.lineStyle(style[0], style[1], style[2]);
      var pointsContainer = new Container(t);
      var points = [];
      var path = [];

      for (var i = 0; i < t.numOfParams; i++) {
        var angle = Math.PI + Math.PI * 2 * i / t.numOfParams;
        var r = t.circleRadiuses[t.numOfSegments] + (t.circleRadiuses[0] - t.circleRadiuses[t.numOfSegments]) * val[i];
        var x = Math.sin(angle) * r;
        var y = Math.cos(angle) * r;
        path.push(new PIXI.Point(x, y));
        points[i] = new Circle(pointsContainer, style[0], [0, 0, 0], [style[1], style[2]]);
        points[i].position.set(x, y);
      }

      g.drawPolygon(path);

      if (t.convertedToSprite) {
        line = new PIXI.Sprite(g.generateCanvasTexture(PIXI.settings.SCALE_MODE, 2));
        line.anchor.set(0.5);
      } else {
        line = g;
      }

      t.addChild(line);

      line["delete"] = function () {
        line.destroy(line.parent.convertedToSprite);
      };

      line.style = style;
      t.lines[lineIndex] = line;
      t.points[lineIndex] = pointsContainer;
      t.values[lineIndex] = val;
    };

    t.updateLine = function (val, lineIndex) {
      lineIndex = lineIndex || 0;
      var lineStyle = [5, 0x000000, 1];

      if (t.lines[lineIndex]) {
        lineStyle = t.lines[lineIndex].style;
        t.lines[lineIndex]["delete"]();
        t.points[lineIndex]["delete"]();
      }

      t.drawLine(val, lineStyle, lineIndex);
    }; //dodati ease
    //dodati ease
    //dodati ease


    t.animateLine = function (val, duration, lineIndex) {
      lineIndex = lineIndex || 0;
      if (duration == undefined) duration = 200;

      for (var i = 0; i < duration; i += 20) {
        var currentVal = [];

        for (var j = 0; j < val.length; j++) {
          currentVal[j] = t.values[lineIndex][j] + (val[j] - t.values[lineIndex][j]) * i / duration;
        }

        setTimeout(function (v, ind) {
          t.updateLine(v, ind);
        }, i, currentVal, lineIndex);
      }

      setTimeout(function (v, ind) {
        t.updateLine(v, ind);
      }, duration, val, lineIndex);
    };

    t.getName = function () {
      return t.type;
    };

    t.setParamNames = function (paramNames, textStyle) {
      for (var i = 0; i < t.numOfParams; i++) {
        t.paramNames[i].text = paramNames[i];
        if (textStyle) t.paramNames[i].style = textStyle;
      }
    };

    return t;
  } //Rectangle class - based on PIXI.Graphics
  //required: parent, size[width, height];
  //optional: size[,,borderRadius], lineStyle[tickness, color, alpha], fillStyle[color,alpha], convertToSprite(def: true),


  function Rectangle(parent, size, lineStyle, fillStyle, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    size[2] = size[2] || 0;
    lineStyle = lineStyle || [0, 0, 0];
    fillStyle = fillStyle || [0xffffff, 1];
    var g = new PIXI.Graphics();

    if (lineStyle.length > 0) {
      g.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);
    }

    if (fillStyle.length > 0) {
      g.beginFill(fillStyle[0], fillStyle[1]);
    } else {
      g.beginFill();
    }

    if (convertToSprite) {
      g.drawRoundedRect(0, 0, size[0], size[1], size[2]);
      g.endFill();
      var t = new PIXI.Sprite(g.generateCanvasTexture(PIXI.settings.SCALE_MODE, 2));
      t.anchor.set(0.5);
      t.type = "Rectangle Sprite";
    } else {
      g.drawRoundedRect(-size[0] * 0.5, -size[1] * 0.5, size[0], size[1], size[2]);
      g.endFill();
      var t = g;
      t.type = "Rectangle Graphics";
    }

    addCommonProps(t);
    t.convertedToSprite = convertToSprite;
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(t.convertedToSprite);
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //Polygon class - based on PIXI.Graphics
  //required: parent, radius, sides;
  //optional: lineStyle[tickness, color, alpha], fillStyle[color,alpha], convertToSprite(def: true)


  function Polygon(parent, radius, sides, lineStyle, fillStyle, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    lineStyle = lineStyle || [0, 0, 0];
    fillStyle = fillStyle || [0xffffff, 1];
    var g = new PIXI.Graphics();

    if (lineStyle.length > 0) {
      g.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);
    }

    if (fillStyle.length > 0) {
      g.beginFill(fillStyle[0], fillStyle[1]);
    } else {
      g.beginFill();
    }

    var path = [];

    for (var i = 0; i < sides; i++) {
      var angle = 2 * Math.PI * (i + 0.5) / sides;
      var x = Math.sin(angle) * radius;
      var y = Math.cos(angle) * radius;
      path.push(new PIXI.Point(x, y));
    }

    g.drawPolygon(path);
    g.endFill();

    if (convertToSprite) {
      var t = new PIXI.Sprite(g.generateCanvasTexture(PIXI.settings.SCALE_MODE, 2));
      t.anchor.set(0.5);
      t.type = "Polygon Sprite";
    } else {
      var t = g;
      t.type = "Polygon Graphics";
    }

    addCommonProps(t);
    t.convertedToSprite = convertToSprite;
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(t.convertedToSprite);
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //Star class - based on PIXI.Graphics
  //required: parent, radiuses[r1,r2];
  //optional: lineStyle[tickness, color, alpha], fillStyle[color,alpha], convertToSprite(def: true)


  function Star(parent, radiuses, sides, lineStyle, fillStyle, convertToSprite) {
    if (convertToSprite == undefined) convertToSprite = true;
    lineStyle = lineStyle || [0, 0, 0];
    fillStyle = fillStyle || [0xffffff, 1];
    radiuses.sort(function (a, b) {
      return a - b;
    });
    var g = new PIXI.Graphics();

    if (lineStyle.length > 0) {
      g.lineStyle(lineStyle[0], lineStyle[1], lineStyle[2]);
    }

    if (fillStyle.length > 0) {
      g.beginFill(fillStyle[0], fillStyle[1]);
    } else {
      g.beginFill();
    }

    var path = [];

    for (var i = 0; i < sides * 2; i++) {
      var angle = Math.PI * i / sides;
      var x = Math.sin(angle) * radiuses[i % 2];
      var y = Math.cos(angle) * radiuses[i % 2];
      path.push(new PIXI.Point(x, y));
    }

    g.drawPolygon(path);
    g.endFill();

    if (convertToSprite) {
      var t = new PIXI.Sprite(g.generateCanvasTexture(PIXI.settings.SCALE_MODE, 2));
      t.anchor.set(0.5);
      t.type = "Star Sprite";
    } else {
      var t = g;
      t.type = "Star Graphics";
    }

    addCommonProps(t);
    t.convertedToSprite = convertToSprite;
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy(t.convertedToSprite);
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  } //Dust class
  //required: parent, numOfParticles, radius
  //optional: colors(def: [0xFFFFFF]); scaleDeviation(def: 0)


  function Dust(parent, radius, numOfParticles, colors, scaleDeviation) {
    if (colors == undefined) colors = [0xffffff];
    scaleDeviation = scaleDeviation || 0;
    var t = new Container(parent);
    t.type = "Dust";
    t.numOfParticles = numOfParticles;
    t.colors = colors;
    t.particles = [];

    for (var i = 0; i < t.numOfParticles; i++) {
      t.particles[i] = new Circle(t, radius * (1 + scaleDeviation));

      t.particles[i].reset = function () {
        this.x = random(APP.screen.width);
        this.y = random(APP.screen.height);
        this.xSpeed = Math.random() * 1 - 0.5;
        this.ySpeed = Math.random() * 1 - 0.5;
        this.currentFrame = 0;
        this.duration = random(100, 200);
        this.tint = randomElement(t.colors);
        this.scale.set(ratio_scale / (1 + scaleDeviation) * (1 + random(-scaleDeviation * 100, scaleDeviation * 100) * 0.01));
      };

      t.particles[i].reset();
    } //methods


    t.reset = function () {
      for (var i = 0; i < t.numOfParticles; i++) {
        t.particles[i].reset();
      }
    };

    t.update = function (delta) {
      for (var i = 0; i < t.numOfParticles; i++) {
        t.particles[i].currentFrame += delta;
        t.particles[i].x += t.particles[i].xSpeed * delta * ratio_scale;
        t.particles[i].y += t.particles[i].ySpeed * delta * ratio_scale;

        if (t.particles[i].currentFrame <= 20) {
          t.particles[i].alpha = t.particles[i].currentFrame / 20;
        }

        if (t.particles[i].currentFrame >= t.particles[i].duration - 20) {
          t.particles[i].alpha = (t.particles[i].duration - t.particles[i].currentFrame) / 20;
        }

        if (t.particles[i].currentFrame >= t.particles[i].duration) {
          t.particles[i].reset();
        }
      }
    };

    t["delete"] = function () {
      for (var i = t.numOfParticles - 1; i >= 0; i--) {
        t.particles[i]["delete"]();
      }

      TweenMax.killTweensOf(t);
      APP.ticker.remove(t.update);
      resize_methods.splice(resize_methods.indexOf(t.reset), 1);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    APP.ticker.add(t.update);
    resize_methods.push(t.reset);
    return t;
  }

  function Explosion(parent, radius, texture, numOfParticles, duration, colors) {
    if (colors == undefined) colors = [0xffffff];
    duration = duration || 0.25;

    if (typeof texture == "string") {
      if (PIXI.utils.TextureCache[texture] != undefined) {
        texture = PIXI.utils.TextureCache[texture];
      } else {
        texture = PIXI.Texture.fromImage(texture);
      }
    }

    var t = new Container(parent);
    t.type = "Particles";
    t.numOfParticles = numOfParticles;
    t.colors = colors;
    t.particles = [];

    for (var i = 0; i < t.numOfParticles; i++) {
      t.particles[i] = new PIXI.Sprite(texture);
      t.addChild(t.particles[i]);
      t.particles[i].tint = colors[i % colors.length];
      if (t.numOfParticles % 2 == 0) var angle = degToRad(180 / t.numOfParticles + 360 * i / t.numOfParticles);else var angle = degToRad(-90 / t.numOfParticles + 360 * i / t.numOfParticles);
      t.particles[i].rotation = angle;
      t.particles[i].endX = Math.cos(angle) * radius;
      t.particles[i].endY = Math.sin(angle) * radius;
      t.particles[i].posTween = TweenMax.to(t.particles[i], duration, {
        pixi: {
          x: t.particles[i].endX,
          y: t.particles[i].endY //alpha: 0,

        },
        ease: Power2.easeOut,
        delay: 0,
        onComplete: function onComplete(i) {
          if (i == t.numOfParticles - 1) {
            t["delete"]();
          }
        },
        onCompleteParams: [i]
      });
      t.particles[i].scaleTween = TweenMax.to(t.particles[i], duration * 0.33, {
        pixi: {
          scale: 0
        },
        ease: Power2.easeOut,
        delay: duration * 0.66
      });

      t.particles[i]["delete"] = function () {
        TweenMax.killTweensOf(this);
        this.parent.removeChild(this);
        this.destroy();
      };
    }

    t["delete"] = function () {
      for (var i = t.numOfParticles - 1; i >= 0; i--) {
        t.particles[i]["delete"]();
      }

      TweenMax.killTweensOf(t);
      t.parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  }

  function Waves(parent, radius, lineWidth, numOfWaves, duration, colors) {
    if (colors == undefined) colors = [0xffffff];
    duration = duration || 0.25;
    var t = new Container(parent);
    t.type = "Waves";
    t.numOfWaves = numOfWaves;
    t.colors = colors;
    t.waves = [];

    for (var i = 0; i < t.numOfWaves; i++) {
      t.waves[i] = new Circle(t, radius, [lineWidth, 0xffffff, 1], [0, 0]);
      t.waves[i].tint = colors[i % colors.length];
      t.waves[i].scale.set(0);
      t.waves[i].scaleTween = TweenMax.to(t.waves[i], duration, {
        pixi: {
          scale: 1
        },
        ease: Power2.easeOut,
        delay: i * 0.2,
        onComplete: function onComplete(i) {
          if (i == t.numOfWaves - 1) {
            t["delete"]();
          }
        },
        onCompleteParams: [i]
      });
      t.waves[i].alphaTween = TweenMax.to(t.waves[i], duration * 0.2, {
        pixi: {
          alpha: 0
        },
        ease: Power2.easeOut,
        delay: i * 0.2 + duration * 0.8
      });
    }

    t.getName = function () {
      return t.type;
    };

    return t;
  } //White Rectangle class - based on PIXI.Texture.WHITE
  //required: parent, size[width, height];
  //optional: color (def: 0xFFFFFF)


  function WhiteRectangle(parent, size, color) {
    if (color == undefined) color = 0xffffff;
    var t = new PIXI.Sprite(PIXI.Texture.WHITE);
    t.width = size[0];
    t.height = size[1];
    t.defaultScaleX = t.scale.x;
    t.defaultScaleY = t.scale.y;
    t.tint = color;
    t.type = "White Rectangle Sprite";
    addCommonProps(t);
    t.anchor.set(0.5);
    parent.addChild(t); //methods

    t["delete"] = function () {
      TweenMax.killTweensOf(t);
      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    t.getName = function () {
      return t.type;
    };

    return t;
  }

  var keyboardControls = {
    keyIsDown: [],
    buttons: [],
    downEvents: [],
    upEvents: []
  };

  keyboardControls.onKeyDown = function (event) {
    if (event.repeat) {
      return;
    }

    event.preventDefault();
    keyboardControls.keyIsDown[event.keyCode] = true;

    var events = _toConsumableArray(keyboardControls.downEvents);

    for (var i = 0; i < events.length; i++) {
      if (events[i].keys.indexOf(event.code) > -1) {
        events[i].callback(events[i].params);
      }
    }
  };

  keyboardControls.onKeyUp = function (event) {
    event.preventDefault();
    keyboardControls.keyIsDown[event.code] = false;

    var buttons = _toConsumableArray(keyboardControls.buttons); //buttons


    for (var i = 0; i < buttons.length; i++) {
      if (buttons[i] && buttons[i].callback && buttons[i].interactive && buttons[i].keys.indexOf(event.code) > -1) {
        buttons[i].callback(buttons[i]);

        if (buttons[i].style && buttons[i].style.clickSound) {
          playSound(buttons[i].style.clickSound);
        }
      }
    }

    var events = _toConsumableArray(keyboardControls.upEvents);

    for (var i = 0; i < events.length; i++) {
      if (events[i].keys.indexOf(event.code) > -1) {
        events[i].callback(events[i].params);
      }
    }
  };

  keyboardControls.addButton = function (button) {
    keyboardControls.buttons.push(button);
  };

  keyboardControls.removeButton = function (button) {
    var ind = keyboardControls.buttons.indexOf(button);

    if (ind > -1) {
      keyboardControls.buttons.splice(ind, 1);
    }
  };

  keyboardControls.addDownEvent = function (keys, callback, params) {
    var event = {
      keys: keys,
      callback: callback,
      params: params
    };
    keyboardControls.downEvents.push(event);
    return event;
  };

  keyboardControls.removeDownEvent = function (event) {
    var ind = keyboardControls.downEvents.indexOf(event);

    if (ind > -1) {
      keyboardControls.downEvents.splice(ind, 1);
    }
  };

  keyboardControls.addUpEvent = function (keys, callback, params) {
    var event = {
      keys: keys,
      callback: callback,
      params: params
    };
    keyboardControls.upEvents.push(event);
    return event;
  };

  keyboardControls.removeUpEvent = function (event) {
    var ind = keyboardControls.upEvents.indexOf(event);

    if (ind > -1) {
      keyboardControls.upEvents.splice(ind, 1);
    }
  };

  window.addEventListener("keydown", keyboardControls.onKeyDown, false);
  window.addEventListener("keyup", keyboardControls.onKeyUp, false);

  function degToRad(deg) {
    return Math.PI * deg / 180;
  }

  function radToDeg(rad) {
    return rad * 180 / Math.PI;
  } //angle between two points


  function angle(p1, p2) {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
  }

  function matrix(m, n, value) {
    value = value || 0;
    var i, j;
    var mat = [];

    for (i = 0; i < m; i++) {
      mat[i] = [];

      for (j = 0; j < n; j++) {
        mat[i][j] = value;
      }
    }

    return mat;
  }

  function pointInsideRect(rect, x, y) {
    var rx = rect.x;
    var ry = rect.y;

    if (rect.anchor) {
      rx = rect.x - rect.anchor.x * rect.width;
      ry = rect.y - rect.anchor.y * rect.height;
    }

    return x > rx && x < rx + rect.width && y > ry && y < ry + rect.height;
  }

  function saveObject(name, obj) {
    try {
      if (localStorage) localStorage.setItem(name, JSON.stringify(obj));
    } catch (e) {}
  }

  function loadObject(name) {
    try {
      if (localStorage) return JSON.parse(localStorage.getItem(name));
    } catch (e) {}

    return null;
  }

  function textTruncate(string, maxLength, upperCase) {
    var corected_string = string;

    if (upperCase) {
      corected_string = corected_string.toUpperCase();
    } else {
      corected_string = corected_string.charAt(0).toUpperCase() + corected_string.slice(1);
    }

    if (maxLength == undefined) {
      return corected_string;
    } else if (corected_string.length > maxLength) {
      return corected_string.substr(0, maxLength - 3) + "...";
    } else {
      return corected_string;
    }
  }

  function numberWithCommas(num, addCurrency) {
    addCurrency = addCurrency || true;
    var parts;

    if (num < 0.01) {
      parts = myFixed(num, 4).split(".");
    } else {
      parts = myFixed(num, 2).split(".");
    }

    function myFixed(num, d) {
      if (!d) return num.toFixed(d); // don't go wrong if no decimal

      return Math.abs(num).toFixed(d).replace(/\.?0+$/, "");
    }

    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");

    if (!addCurrency) {
      return parts.join(".");
    } else {
      return parts.join(".") + " " + currency_str;
    }
  }

  function numberWithDecimal(val) {
    return Math.abs(Number(val.toFixed(6)));
  }

  var fpsText;

  function showFPS(anchorX, anchorY) {
    fpsText = new Text(APP.stage);
    fpsText.x = APP.screen.width * anchorX;
    fpsText.y = APP.screen.height * anchorY;
    fpsText.anchor.set(anchorX, anchorY);
    fpsText.interval = setInterval(function () {
      fpsText.text = Math.round(APP.ticker.FPS);
    }, 100);
  }

  function hideFPS() {
    clearInterval(fpsText.interval);
    fpsText["delete"]();
  }

  function getOS() {
    var userAgent = window.navigator.userAgent,
        platform = window.navigator.platform,
        macosPlatforms = ["Macintosh", "MacIntel", "MacPPC", "Mac68K"],
        windowsPlatforms = ["Win32", "Win64", "Windows", "WinCE"],
        iosPlatforms = ["iPhone", "iPad", "iPod"],
        os = null;

    if (macosPlatforms.indexOf(platform) !== -1) {
      os = "Mac OS";
    } else if (iosPlatforms.indexOf(platform) !== -1) {
      os = "iOS";
    } else if (windowsPlatforms.indexOf(platform) !== -1) {
      os = "Windows";
    } else if (/Android/.test(userAgent)) {
      os = "Android";
    } else if (!os && /Linux/.test(platform)) {
      os = "Linux";
    }

    return os;
  } //parse time


  function parseTime(timeString) {
    var arr = timeString.split(/[\-\+ :T]/);
    var time = new Date(arr[0], arr[1] - 1, arr[2], arr[3], arr[4], arr[5]);
    var min = time.getMinutes();

    if (min < 10) {
      min = "0" + min;
    }

    var hour = time.getHours();

    if (hour < 10) {
      hour = "0" + hour;
    }

    var date = time.getDate();

    if (date < 10) {
      date = "0" + date;
    }

    var month = time.getMonth() + 1;

    if (month < 10) {
      month = "0" + month;
    }

    return hour + ":" + min + " " + date + "." + month + "." + time.getFullYear();
  } //random integer 0-a or a-b required:a; optional b(def: 0);


  function random(a, b) {
    var b = b || 0;
    return Math.round(a + Math.floor(Math.random() * (b - a)));
  }

  function randomColor() {
    return random(0xffffff);
  }

  function randomName() {
    var name1 = ["Purple", "Old", "Normal", "Cold", "Brave", "Tiny", "Funky", "Lazy", "Calm", "Filthy", "Fancy", "Witty", "Scary", "Huge", "Clumsy", "Kind", "Great"];
    var name2 = ["Bear", "Dog", "Owl", "Cat", "Sparrow", "Dolphin", "Koala", "Shark", "Gorilla", "Otter", "Mole", "Wombat", "Zebra", "Panda", "Fox", "Flower"];
    return randomElement(name1) + " " + randomElement(name2);
  } //random element from array - required: array; optional: removeElement(def: false), probabilityProp(if elements have different probability to be drawn)


  function randomElement(array, removeElement, probabilities) {
    removeElement = removeElement || false;

    if (probabilities) {
      var s = 0;
      rand = Math.random();
      var probabilityProp = typeof probabilities == "string";

      for (var i = 0; i < array.length; i++) {
        if (probabilityProp) {
          s += array[i][probabilities];
        } else {
          s += probabilities[i];
        }

        if (rand < s || i == array.length - 1) {
          var el = array[i];

          if (removeElement) {
            array.splice(i, 1);

            if (!probabilityProp) {
              var chosenProb = probabilities[i];
              probabilities.splice(i, 1);
            }

            for (var j = 0; j < array.length; j++) {
              if (probabilityProp) {
                array[j][probabilities] *= 1 / (1 - el[probabilities]);
              } else {
                probabilities[j] *= 1 / (1 - chosenProb);
              }
            }
          }

          return el;
        }
      }
    } else {
      var randIndex = random(array.length);
      var el = array[randIndex];

      if (removeElement) {
        array.splice(randIndex, 1);
      }

      return el;
    }
  } //pseudorandom


  var prevRandNums;
  var prevRandSum;

  function resetPseudoRandom() {
    prevRandNums = [0, 0, 0];
    prevRandSum = 0;
  }

  function pseudoRandom(seed) {
    seed = (1 + Math.abs(seed + prevRandSum)) * Math.E;
    var newRand = seed - Math.floor(seed);
    prevRandNums.unshift(newRand);
    prevRandSum += newRand - prevRandNums.pop();
    return newRand;
  }

  resetPseudoRandom(); //pseudorandom test
  //var s = 2
  //for (var i = 0; i < 30; i++)
  //    console.log(pseudoRandom(s));
  //
  //var check=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  //for (var i=0;i<1000000;i++)
  //{
  //    check[Math.floor(pseudoRandomInt(s,20))]++;
  //}
  //console.log(check);
  //pseudo random integer from a to b

  function pseudoRandomInt(seed, a, b) {
    var b = b || 0;
    return Math.round(a + Math.floor(pseudoRandom(seed) * (b - a)));
  } //shuffles an array using pseudoRandom


  function pseudoShuffle(seed, array) {
    var len = array.length;

    for (var i = len - 1; i > 0; i--) {
      var rand = pseudoRandomInt(seed, i + 1);
      var p = array[i];
      array[i] = array[rand];
      array[rand] = p;
    }
  }

  function pseudoRandomElement(seed, array) {
    var rand = pseudoRandomInt(seed, array.length);
    return array[rand];
  } //shuffles an array


  function shuffleArray(array) {
    var len = array.length;

    for (var i = len - 1; i > 0; i--) {
      var rand = random(i + 1);
      var p = array[i];
      array[i] = array[rand];
      array[rand] = p;
    }
  }

  function pushElements(array, element, copies) {
    for (var i = 0; i < copies; i++) {
      array.push(element);
    }
  }

  function unshiftElements(array, element, copies) {
    for (var i = 0; i < copies; i++) {
      array.unshift(element);
    }
  }

  var coorStart = {
    x: 0,
    y: 0,
    z: 0
  };

  function distance(a, b) {
    if (b == undefined) b = coorStart;

    if (a.z == undefined) {
      return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    } else {
      return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));
    }
  }

  function isChrome() {
    var isChromium = window.chrome,
        winNav = window.navigator,
        vendorName = winNav.vendor,
        isOpera = winNav.userAgent.indexOf("OPR") > -1,
        isIEedge = winNav.userAgent.indexOf("Edge") > -1,
        isIOSChrome = winNav.userAgent.match("CriOS");

    if (isIOSChrome) {
      return true;
    } else if (isChromium !== null && typeof isChromium !== "undefined" && vendorName === "Google Inc." && isOpera === false && isIEedge === false) {
      return true;
    } else {
      return false;
    }
  }

  var hidden, visibilityChange;

  if (typeof document.hidden !== "undefined") {
    hidden = "hidden";
    visibilityChange = "visibilitychange";
  } else if (typeof document.mozHidden !== "undefined") {
    hidden = "mozHidden";
    visibilityChange = "mozvisibilitychange";
  } else if (typeof document.msHidden !== "undefined") {
    hidden = "msHidden";
    visibilityChange = "msvisibilitychange";
  } else if (typeof document.webkitHidden !== "undefined") {
    hidden = "webkitHidden";
    visibilityChange = "webkitvisibilitychange";
  }

  if (!window.console) {
    window.console = {};
  }

  if (!window.console.log) {
    window.console.log = function () {};
  } // FULL SCREEN TOGGLE **************************************
  // FULL SCREEN TOGGLE **************************************
  // FULL SCREEN TOGGLE **************************************


  var fullScreenSupported = false;

  try {
    if (Modernizr.fullscreen) {
      fullScreenSupported = true;
    } else {
      fullScreenSupported = false;
    }
  } catch (e) {}

  function toggleFullScreen() {
    if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    } else {
      var element = $("body").get(0);

      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      }
    }
  }

  function isFullScreen() {
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
  } //activate all buttons in a given container
  //optional: parent (def: stage), recursive (activates children's children, def: true)


  function enableAllButtons(parent, recursive) {
    parent = parent || APP.stage;
    recursive = recursive || true;

    for (var i = 0; i < parent.children.length; i++) {
      if (parent.children[i].type == "Button") {
        parent.children[i].prevState = parent.children[i].interactive;
        parent.children[i].enable();
      } else if (recursive && parent.children[i].type == "Container") {
        enableAllButtons(parent.children[i], true);
      }
    }
  } //deactivate all buttons in a given container
  //optional: parent (def: stage), recursive (deactivates children's children, def: true)


  function disableAllButtons(parent, recursive) {
    parent = parent || APP.stage;
    recursive = recursive || true;

    for (var i = 0; i < parent.children.length; i++) {
      if (parent.children[i].type == "Button") {
        parent.children[i].prevState = parent.children[i].interactive;
        parent.children[i].disable();
      } else if (recursive && parent.children[i].type == "Container") {
        disableAllButtons(parent.children[i], true);
      }
    }
  } //deactivate all buttons in a given container
  //optional: parent (def: stage), recursive (resets children's children, def: true)


  function resetAllButtons(parent, recursive) {
    parent = parent || APP.stage;
    recursive = recursive || true;

    for (var i = 0; i < parent.children.length; i++) {
      if (parent.children[i].type == "Button") {
        if (parent.children[i].prevState) {
          parent.children[i].enable();
        } else {
          parent.children[i].disable();
        }
      } else if (recursive && parent.children[i].type == "Container") {
        resetAllButtons(parent.children[i], true);
      }
    }
  }

  function clickLog(parent, recursive) {
    parent = parent || APP.stage;
    recursive = recursive || true;
    parent.clickLogEnabled = parent.clickLogEnabled || false;

    for (var i = 0; i < parent.children.length; i++) {
      if (parent.children[i].type != "Container") {
        if (!parent.clickLogEnabled) {
          parent.children[i].oldInteractive = parent.children[i].interactive;
          parent.children[i].interactive = true;
          parent.children[i].on("pointerup", objectLog);
        } else {
          parent.children[i].interactive = parent.children[i].oldInteractive;
          parent.children[i].off("pointerup", objectLog);
        }
      } else if (recursive) {
        clickLog(parent.children[i], true);
      }
    }

    parent.clickLogEnabled = !parent.clickLogEnabled;

    if (parent.clickLogEnabled) {
      return "Click log enabled.";
    } else {
      return "Click log disabled.";
    }
  }

  function objectLog(e) {
    if (this.loggingActive) {
      return;
    }

    if (this.oldAlpha == undefined) {
      this.oldAlpha = this.alpha;
    }

    for (var i = 0; i < 10; i++) {
      setTimeout(function (o, a) {
        o.loggingActive = true;
        o.alpha = a;
      }, i * 200, this, i % 2);
    }

    setTimeout(function (o) {
      o.loggingActive = false;
      o.alpha = o.oldAlpha;
      o.oldAlpha = undefined;
    }, 2000, this);
    console.log("---CLICK LOG---");

    if (this.getName != undefined) {
      console.log(this.getName());
    }

    console.log(this);
    console.log("---------------");
  }

  function drawGuideLines(color) {
    color = color || 0x00ff00;
    APP.stage.guideLines = [];
    var w = APP.screen.width;
    var h = APP.screen.height;
    APP.stage.guideLinesContainer = new Container(APP.stage);
    APP.stage.guideLinesContainer.color = color;
    APP.stage.hGuideLines = [];
    APP.stage.vGuideLines = [];

    for (var i = -10; i < (h + 100) / 10; i++) {
      APP.stage.hGuideLines[i] = new WhiteRectangle(APP.stage.guideLinesContainer, [w, 1], color);
      APP.stage.hGuideLines[i].alpha = 0.1;
      if (i % 5 == 0) APP.stage.hGuideLines[i].alpha = 0.25;
      if (i % 10 == 0) APP.stage.hGuideLines[i].alpha = 0.5;
      APP.stage.hGuideLines[i].setTransform(w / 2, i * 10 + h % 100 / 2);
    }

    for (var i = -10; i < (w + 100) / 10; i++) {
      APP.stage.vGuideLines[i] = new WhiteRectangle(APP.stage.guideLinesContainer, [1, h], color);
      APP.stage.vGuideLines[i].alpha = 0.1;
      if (i % 5 == 0) APP.stage.vGuideLines[i].alpha = 0.25;
      if (i % 10 == 0) APP.stage.vGuideLines[i].alpha = 0.5;
      APP.stage.vGuideLines[i].setTransform(i * 10 + w % 100 / 2, h / 2);
    }

    var hCenter = new WhiteRectangle(APP.stage.guideLinesContainer, [2, h], color);
    hCenter.alpha = 0.5;
    hCenter.setTransform(w / 2, h / 2);
    var vCenter = new WhiteRectangle(APP.stage.guideLinesContainer, [w, 2], color);
    vCenter.alpha = 0.5;
    vCenter.setTransform(w / 2, h / 2);

    APP.stage.guideLinesContainer.resize = function () {
      var color = APP.stage.guideLinesContainer.color;
      clearGuideLines();
      drawGuideLines(color);
    };

    resize_methods.push(APP.stage.guideLinesContainer.resize);
  }

  function clearGuideLines() {
    if (APP.stage.guideLinesContainer) {
      resize_methods.splice(resize_methods.indexOf(APP.stage.guideLinesContainer.resize), 1);
      APP.stage.guideLinesContainer.resize = null;
      APP.stage.guideLinesContainer["delete"]();
      APP.stage.hGuideLines = null;
      APP.stage.vGuideLines = null;
    }
  } //shakes the entire screen
  //optional: container(def: APP.stage)


  function shakeScreen(power, duration, container) {
    container = container || APP.stage;

    if (container.posBeforeShake == undefined) {
      container.posBeforeShake = {
        x: container.x,
        y: container.y
      };
    } else {
      for (var i = 0; i < container.shakeTimeouts.length; i++) {
        clearTimeout(container.shakeTimeouts[i]);
      }
    }

    container.shakeTimeouts = [];

    for (var i = 0; i < duration; i += 30) {
      container.shakeTimeouts.push(setTimeout(function (c) {
        c.x = container.posBeforeShake.x + random(-power / 2, power / 2);
        c.y = container.posBeforeShake.y + random(-power / 2, power / 2);
      }, i, container));
    }

    container.shakeTimeouts.push(setTimeout(function (c) {
      c.position.set(c.posBeforeShake.x, c.posBeforeShake.y);
      c.posBeforeShake = undefined;
      container.shakeTimeouts = undefined;
    }, duration, container));
  }

  function countText(textObject, start, end, duration, soundNames) {
    var parts = duration / 30;
    textObject.oldPlayCountValue = start;

    for (var i = 0; i < parts; i++) {
      setTimeout(function (t, n, s, p) {
        if (t) {
          t.text = n;

          if (s && p && t.oldPlayCountValue != n) {
            playSound(randomElement(s));
            t.oldPlayCountValue = n;
          }
        }
      }, i * 30, textObject, Math.round(start + (i + 1) * (end - start) / parts), soundNames, i % 3 == 0);
    }
  }

  function arrangeToGrid(elements, m, n, xSpace, ySpace, centerX, centerY, duration, delay, delayInc, easing, centerRows, centerColumns) {
    xSpace = xSpace || 0;
    ySpace = ySpace || xSpace;
    centerX = centerX || 0;
    centerY = centerY || 0;
    duration = duration || 0;
    delayInc = delayInc || 0;
    delay = delay || 0;
    easing = easing || Power2.easiOut;
    var numOfElements = elements.length;
    var regStX = centerX + (-n / 2 + 0.5) * (elements[0].width + xSpace);
    var regStY = centerY + (-m / 2 + 0.5) * (elements[0].height + ySpace);

    for (var i = 0; i < m; i++) {
      var stX = regStX;

      if (i == m - 1 && centerRows) {
        stX = ((m * n - numOfElements - n) / 2 + 0.5) * (elements[0].width + xSpace);
      }

      for (var j = 0; j < n; j++) {
        var stY = regStY;

        if (j == n - 1 && centerColumns) {
          stY = ((n * m - numOfElements - m) / 2 + 0.5) * (elements[0].height + ySpace);
        }

        if (i * n + j < numOfElements) {
          if (elements[i * n + j].arrangeToGridAnim) {
            elements[i * n + j].arrangeToGridAnim.kill();
          }

          if (duration === 0) {
            elements[i * n + j].x = stX + j * (elements[0].width + xSpace);
            elements[i * n + j].y = stY + i * (elements[0].height + ySpace);
          } else {
            elements[i * n + j].arrangeToGridAnim = TweenMax.to(elements[i * n + j], duration, {
              pixi: {
                x: stX + j * (elements[0].width + xSpace),
                y: stY + i * (elements[0].height + ySpace)
              },
              ease: easing,
              delay: delay + (i * n + j) * delayInc
            });
          }
        }
      }
    }
  }

  function makeInteractive(obj, eventName, callback) {
    obj.interactive = true;
    obj.buttonMode = true;
    obj.on(eventName, callback);
  }

  function dragAndDrop(obj, onDragStarted, onDrag, onDrop, offsetX, offsetY) {
    offsetX = offsetX || 0;
    offsetY = offsetY || 0;
    obj.dragObj = {};

    obj.dragObj.startDragging = function (e) {
      var t = e.currentTarget;
      t.dragStartPosX = t.x;
      t.dragStartPosY = t.y;

      if (e.data.originalEvent.touches) {
        if (e.data.originalEvent.touches.length > 1) return;
      }

      if (t.dragObj.dragData == null) {
        t.dragObj.transparentRect = new WhiteRectangle(t, [2000, 2000], 0x000000);
        t.dragObj.transparentRect.alpha = 0;
        t.parent.toFront(t);
        t.dragObj.dragData = e.data;
        var newPos = e.data.getLocalPosition(t.parent);
        t.dragObj.offsetX = t.x - newPos.x;
        t.dragObj.offsetY = t.y - newPos.y;
        TweenMax.to(t, 0.1, {
          pixi: {
            x: t.dragStartPosX + (newPos.x + t.dragObj.offsetX - t.dragStartPosX) + offsetX,
            y: t.dragStartPosY + (newPos.y + t.dragObj.offsetY - t.dragStartPosY) + offsetY
          },
          ease: Power2.easeOut
        });

        if (onDragStarted) {
          onDragStarted(e);
        }
      }
    };

    obj.dragObj.drag = function (e) {
      var t = e.currentTarget;

      if (t.dragObj.dragData != null) {
        var newPos = t.dragObj.dragData.getLocalPosition(t.parent);

        if (onDrag) {
          onDrag(e);
        }

        TweenMax.to(t, 0.1, {
          pixi: {
            x: t.dragStartPosX + (newPos.x + t.dragObj.offsetX - t.dragStartPosX) + offsetX,
            y: t.dragStartPosY + (newPos.y + t.dragObj.offsetY - t.dragStartPosY) + offsetY
          },
          ease: Power2.easeOut
        });
      }
    };

    obj.dragObj.drop = function (e) {
      var t = e.currentTarget;

      if (t.dragObj.dragData != null) {
        t.dragObj.transparentRect["delete"]();
        t.dragObj.transparentRect = null;
        t.dragObj.dragData = null;

        if (onDrop) {
          onDrop(e);
        }
      }
    };

    obj.interactive = true;
    obj.on("pointerdown", obj.dragObj.startDragging);
    obj.on("pointermove", obj.dragObj.drag);
    obj.on("pointerout", obj.dragObj.drop);
    obj.on("pointerupoutside", obj.dragObj.drop);
    obj.on("pointerup", obj.dragObj.drop);
  }

  function stopDragAndDrop(obj) {
    obj.interactive = true;
    obj.off("pointerdown", obj.dragObj.startDragging);
    obj.off("pointermove", obj.dragObj.drag);
    obj.off("pointerout", obj.dragObj.drop);
    obj.off("pointerupoutside", obj.dragObj.drop);
    obj.off("pointerup", obj.dragObj.drop);

    if (obj.dragObj.transparentRect) {
      obj.dragObj.transparentRect["delete"]();
    }

    obj.dragObj = null;
  }

  function isConnected() {
    //    if (window.JSInterface)
    //            return (window.JSInterface.isConnected()=="true")
    //    else
    return is.online();
  }

  var shareToSocial = {
    reddit: function reddit(msg, url) {
      var msg = encodeURI(msg);
      window.open("https://www.reddit.com/submit?url=" + url + "&title=" + msg, "_blank");
    },
    twitter: function twitter(msg, url) {
      var msg = encodeURI(msg + " " + url);
      window.open("https://twitter.com/intent/tweet?text=" + msg, "_blank");
    },
    facebook: function facebook(msg, url) {
      //var msg = encodeURI(msg);
      window.open("http://www.facebook.com/sharer.php?u=" + url, "_blank");
    },
    email: function email(msg, url) {
      var msg = encodeURI(msg + " " + url);
      window.open("mailto:?body=" + msg, "_blank");
    },
    whatsapp: function whatsapp(msg, url) {
      window.open("whatsapp://send?text=" + msg + " " + url, "_blank");
    },
    telegram: function telegram(msg, url) {
      var msg = encodeURI(msg);
      window.open("https://t.me/share/url?url=" + url + "&text=" + msg, "_blank");
    },
    viber: function viber(msg, url) {
      window.open("viber://forward?text=" + msg + " " + url, "_blank");
    }
  };

  var shareOnMobile = function shareOnMobile(msg, url) {
    try {
      navigator.share({
        url: url,
        text: msg
      });
    } catch (e) {}
  };

  var ads = {}; //var PokiSDK;



  ads.lastAdTime = Date.now();
  ads.wait = 0 * 60 * 1000; //0 minutes

  ads.shareableURL = null;

  ads.init = function () {
    if (PokiSDK == undefined) {
      return;
    }

    ads.adBlocker = false;
    PokiSDK.init().then(function () {
      ads.setShareableURL();
    })["catch"](function () {
      ads.adBlocker = true;
    });
    PokiSDK.setDebug(false);
  };

  ads.init();

  ads.showAd = function (callback) {
    if (PokiSDK == undefined) return;
    PokiSDK.commercialBreak().then(function () {
      //console.log('End of commercial break');
      if (callback) {
        callback();
      }
    })["catch"](function () {//adblock
    });
  };

  ads.showRewardedVideo = function (placement, callback) {
    if (PokiSDK == undefined) return;
    ads.videoIsActive = true;
    PokiSDK.rewardedBreak().then(function (withReward) {
      ads.videoIsActive = false;

      if (callback) {
        callback();
      }

      if (withReward) {
        gameLogic.rewardPlayer();
        ads.lastAdTime = Date.now();
      } else {
        if (ads.adBlocker) {
          setTimeout(gameScreen.openWarning, 750, "adBlockerTitle", "adBlockerText");
        } else {
          setTimeout(gameScreen.openWarning, 750, "oopsTitle", "oopsText");
        }
      }
    });
  };

  ads.onVideoStarted = function () {
    ads.videoIsActive = true;
  };

  ads.onVideoClosed = function () {
    ads.videoIsActive = false;
    ads.lastAdTime = Date.now();
  };

  ads.onVideoCompleted = function () {};

  ads.onVideoNotAvailable = function () {
    setTimeout(gameScreen.openWarning, 750, "noAdsTitle", "noAdsText");
  };

  ads.getWaitingTime = function () {
    return Math.max(0, ads.wait + ads.lastAdTime - Date.now());
  };

  ads.happyTime = function (power) {
    if (PokiSDK == undefined) return;
    PokiSDK.happyTime(power);
  };

  ads.gameplayStop = function () {
    if (PokiSDK == undefined) return;
    PokiSDK.gameplayStop();
    console.log("stop");
  };

  ads.gameplayStart = function () {
    if (PokiSDK == undefined) return;
    PokiSDK.gameplayStart();
    console.log("start");
  };

  ads.gameLoadingStart = function () {
    if (PokiSDK == undefined) return;
    PokiSDK.gameLoadingStart();
  };

  ads.gameLoadingFinished = function () {
    if (PokiSDK == undefined) return;
    PokiSDK.gameLoadingFinished();
  };

  ads.gameLoadingProgress = function (progress) {
    if (PokiSDK == undefined) return;
    var data = {};
    data.percentageDone = progress;
    PokiSDK.gameLoadingProgress(data);
  };

  ads.setShareableURL = function (params) {
    PokiSDK.shareableURL(params).then(function (url) {
      ads.shareableURL = url;
    });
  }; //sitelock


  var _0x1918 = ["top", "indexOf", "aHR0cHM6Ly9wb2tpLmNvbS9zaXRlbG9jaw==", "hostname", "length", "location", "LnBva2ktZ2RuLmNvbQ==", "href"];

  (function (_0x4a02b5, _0x5c0c3d) {
    var _0x56a85d = function _0x56a85d(_0x375c0e) {
      while (--_0x375c0e) {
        _0x4a02b5.push(_0x4a02b5.shift());
      }
    };

    _0x56a85d(++_0x5c0c3d);
  })(_0x1918, 0x1ae);

  var _0xcdc9 = function _0xcdc9(_0x4a02b5, _0x5c0c3d) {
    _0x4a02b5 -= 0x0;
    var _0x56a85d = _0x1918[_0x4a02b5];
    return _0x56a85d;
  };

  (function checkInit() {/*
    var _0x151adb = ["bG9jYWxob3N0", "LnBva2kuY29t", _0xcdc9("0x0")];

    var _0x219654 = ![];

    var _0x558823 = window[_0xcdc9("0x7")][_0xcdc9("0x5")];

    for (var _0x220888 = 0x0; _0x220888 < _0x151adb[_0xcdc9("0x6")]; _0x220888++) {
      var _0x4a2f49 = atob(_0x151adb[_0x220888]);

      if (_0x558823[_0xcdc9("0x3")](_0x4a2f49, _0x558823.length - _0x4a2f49.length) !== -0x1) {
        _0x219654 = !![];
        break;
      }
    }

    if (!_0x219654) {
      var _0xcff8e8 = _0xcdc9("0x4");

      var _0x3296f7 = atob(_0xcff8e8);

      window.location[_0xcdc9("0x1")] = _0x3296f7;
      window[_0xcdc9("0x2")][_0xcdc9("0x7")] !== window[_0xcdc9("0x7")] && (window[_0xcdc9("0x2")][_0xcdc9("0x7")] = window[_0xcdc9("0x7")]);
    }*/
  })();

  var primaryPalette = [0xffffff, 0x030303, 0xd14100];
  var secondaryPalette = [0xffffff, 0x030303, 0xfec700];
  var gemColors = [0xffffff, 0x2e2852, 0x7f30a2, 0xd46abd, 0x2b7fa0, 0x3e6ab0, 0x3b354e, 0xba13a2, 0xc16219, 0xe99b35, 0xf55200, 0xf8273a];
  var wildColors = [0x2c78ea, 0x37d5f3, 0xbb5cf2, 0xe037e9];

  function hexToRgb(hex) {
    return [Math.floor(hex / (256 * 256)), Math.floor(hex % (256 * 256) / 256), hex % 256];
  }

  function rgbToHex(rgb) {
    return rgb[0] * 256 * 256 + rgb[1] * 256 + rgb[2];
  }

  function multiplyColor(hex, multiplier) {
    var rgb = hexToRgb(hex);
    rgb[0] *= multiplier;
    rgb[1] *= multiplier;
    rgb[2] *= multiplier;
    return rgbToHex(rgb);
  }

  function fadeToColor(obj, color, alpha, duration) {
    var currentRGB = hexToRgb(obj.tint);
    var currentAlpha = obj.alpha;
    var targetRGB = hexToRgb(color);
    var targetAlpha = alpha;
    obj.fadeColorId = obj.fadeColorId || 0;
    obj.fadeColorId++;
    var fadeColorId = obj.fadeColorId;

    for (var i = 0; i <= duration; i += 20) {
      if (i > duration - 20) {
        i = duration;
      }

      var newRGB = [];
      newRGB[0] = Math.round(currentRGB[0] + (targetRGB[0] - currentRGB[0]) * (i / duration));
      newRGB[1] = Math.round(currentRGB[1] + (targetRGB[1] - currentRGB[1]) * (i / duration));
      newRGB[2] = Math.round(currentRGB[2] + (targetRGB[2] - currentRGB[2]) * (i / duration));
      var newHex = rgbToHex(newRGB);
      var newAlpha = currentAlpha + (targetAlpha - currentAlpha) * (i / duration);
      setTimeout(function (o, c, a, id) {
        if (id != o.fadeColorId || o == undefined) return;
        o.tint = c;
        o.alpha = a;
      }, i, obj, newHex, newAlpha, fadeColorId);
    }
  }

  var aspectRatio;
  var ratio_scale = 0;
  var resize_methods = [];
  var maxAspectRatio = 3;
  var minAspectRatio = 1 / maxAspectRatio;
  var resize_methods = [];
  var formats = [16 / 9, 9 / 16, 4 / 3];
  var LANDSCAPE = 0;
  var PORTRAIT = 1;
  var DESKTOP = 2;
  var currentFormat; //  performace / resolution

  var canvas_scale = 1;

  if (is.mobile()) {
    canvas_scale = 1;
  }

  function resize() {
    if (APP == undefined) return;
    var width_inner = window.innerWidth / canvas_scale;
    var height_inner = window.innerHeight / canvas_scale;

    if (width_inner / height_inner > maxAspectRatio) {
      width_inner = height_inner * maxAspectRatio;
    }

    if (width_inner / height_inner < minAspectRatio) {
      height_inner = width_inner / minAspectRatio;
    }

    APP.renderer.resize(width_inner, height_inner);
    setRatioScale();
    aspectRatio = APP.screen.width / APP.screen.height;
    var minDiff = 99999;
    var minIndex;

    for (var i = 0; i < formats.length; i++) {
      var diff = Math.abs(formats[i] - aspectRatio);

      if (diff < minDiff) {
        minIndex = i;
        minDiff = diff;
      }
    }

    currentFormat = minIndex;

    for (var i = 0; i < resize_methods.length; i++) {
      resize_methods[i]();
    } //    var scaleX = window.innerWidth / APP.screen.width;
    //    var scaleY = window.innerHeight / APP.screen.height;
    //
    //    var scaleToFit = Math.min(scaleX, scaleY);
    //    var scaleToCover = Math.max(scaleX, scaleY);


    APP.view.style.transformOrigin = "0 0";
    APP.view.style.transform = "scale(" + canvas_scale + ")";
  }

  function setRatioScale() {
    if (window.innerHeight < window.innerWidth) {
      ratio_scale = window.innerHeight / 1080 / canvas_scale;
    } else {
      ratio_scale = window.innerWidth / 1080 / canvas_scale;
    }
  }

  $(window).on("resize", function () {
    if (getOS() == "iOS") {
      setTimeout(function () {
        resize();
      }, 150);
    } else {
      resize();
    }
  });
  var localization = {};
  var language = loadObject("language") || window.navigator.userLanguage || window.navigator.language;
  language = language.substring(0, 2); //en, fr, it, de, es, pt, ru, tr, zh, ja, ko

  function getText(key, values) {
    if (!localization[language]) {
      language = "en";
    }

    var str = localization[language][key];

    if (values) {
      for (var i = 0; i < values.length; i++) {
        str = str.replace("[" + i + "]", values[i]);
      }
    }

    return str;
  }

  function setLanguage(lang) {
    language = lang;
    saveObject("language", lang);
  } //English


  localization.en = {
    next: "next",
    powerUpTitle0: "Level up",
    powerUpTitle1: "Gem 123",
    powerUpTitle2: "Shifting",
    powerUpTitle3: "Revive",
    powerUpText0: "Turn all level 1 gems into level 2 gems.",
    powerUpText1: "Turn the upcoming gem into a 123 gem.",
    powerUpText2: "Rearrange gems on the board.",
    powerUpText3: "Undo your last 20 moves.",
    ad: "Watch an ad to activate.",
    noAdsTitle: "Not available",
    noAdsText: "No ads are available at this moment. Please try again in a few seconds.",
    noInternetTitle: "No Internet",
    noInternetText: "Make sure you are connected to the Internet.",
    adBlockerTitle: "Ad blocker",
    adBlockerText: "Please disable your ad blocker and refresh the page.",
    oopsTitle: "Oops",
    oopsText: "Something went wrong. Please try again in a few seconds.",
    share: "Play Gem·11!",
    shareScore: "I scored [0] points in Gem 11. Can you beat me? Play on POKI!"
  }; //French

  localization.fr = {
    next: "prochain",
    powerUpTitle0: "Progrès",
    powerUpTitle1: "Gemme 123",
    powerUpTitle2: "Déplacement",
    powerUpTitle3: "Relancer",
    powerUpText0: "Transformez toutes les gemmes de niveau 1 en gemmes de niveau 2.",
    powerUpText1: "Transforme la gemme à venir en gemme 123.",
    powerUpText2: "Réorganisez les gemmes sur le plateau.",
    powerUpText3: "Reculez de 20 coups.",
    ad: "Regardez une annonce pour activer.",
    noAdsTitle: "Indisponible",
    noAdsText: "Aucune annonce n'est disponible pour le moment. Veuillez réessayer dans quelques secondes.",
    noInternetTitle: "Pas d'Internet",
    noInternetText: "Assurez-vous que vous êtes connecté à Internet.",
    adBlockerTitle: "Bloqueur de publicités",
    adBlockerText: "Veuillez désactiver votre bloqueur de publicités et actualiser la page.",
    oopsTitle: "Oops",
    oopsText: "Quelque chose s'est mal passé. Veuillez réessayer dans quelques secondes.",
    share: "Jouer Gem·11!",
    shareScore: "J'ai marqué [0] points dans Gem·11. Peux-tu me battre? Jouez sur POKI !"
  }; //Italian

  localization.it = {
    next: "prossima",
    powerUpTitle0: "Progresso",
    powerUpTitle1: "Gemma 123",
    powerUpTitle2: "Mutevole",
    powerUpTitle3: "Rivivere",
    powerUpText0: "Trasforma tutte le gemme di livello 1 in gemme di livello 2.",
    powerUpText1: "Trasforma la gemma in arrivo in una gemma 123.",
    powerUpText2: "Riordina le gemme sul tabellone.",
    powerUpText3: "Torna indietro di 20 mosse.",
    ad: "Guarda un annuncio per attivare.",
    noAdsTitle: "Non disponibile",
    noAdsText: "Nessun annuncio disponibile in questo momento. Riprova tra qualche secondo.",
    noInternetTitle: "Senza internet",
    noInternetText: "Assicurati di essere connesso a Internet.",
    adBlockerTitle: "Blocco per annunci pubblicitari",
    adBlockerText: "Disattiva il blocco degli annunci e aggiorna la pagina.",
    oopsTitle: "Ops",
    oopsText: "Qualcosa è andato storto. Riprova tra qualche secondo.",
    share: "Gioca a Gem·11!",
    shareScore: "Ho segnato [0] punti in Gem 11. Puoi battermi? Gioca su POKI!"
  }; //German

  localization.de = {
    next: "nächste",
    powerUpTitle0: "Aufleveln",
    powerUpTitle1: "Edelstein 123",
    powerUpTitle2: "Verschiebung",
    powerUpTitle3: "Beleben",
    powerUpText0: "Verwandle alle Edelsteine der Stufe 1 in Edelsteine der Stufe 2.",
    powerUpText1: "Verwandeln Sie den kommenden Edelstein in einen 123-Edelstein.",
    powerUpText2: "Ordne Edelsteine auf dem Brett neu an.",
    powerUpText3: "Gehe 20 Züge zurück",
    ad: "Sehen Sie sich eine Anzeige an, um sie zu aktivieren.",
    noAdsTitle: "Nicht verfügbar",
    noAdsText: "Im Moment sind keine Anzeigen verfügbar. Bitte versuchen Sie es in ein paar Sekunden erneut.",
    noInternetTitle: "Kein Internet",
    noInternetText: "Stellen Sie sicher, dass Sie mit dem Internet verbunden sind.",
    adBlockerTitle: "Werbungsblocker",
    adBlockerText: "Bitte deaktivieren Sie Ihren Werbeblocker und aktualisieren Sie die Seite.",
    oopsTitle: "Hoppla",
    oopsText: "Etwas ist schief gelaufen. Bitte versuchen Sie es in ein paar Sekunden erneut.",
    share: "Spiele Gem·11!",
    shareScore: "Ich habe in Gem·11 [0] Punkte erzielt. Kannst du mich schlagen? Spielen Sie auf POKI!"
  }; //Spanish

  localization.es = {
    next: "próxima",
    powerUpTitle0: "Progreso",
    powerUpTitle1: "Gema 123",
    powerUpTitle2: "Cambiando",
    powerUpTitle3: "Renacer",
    powerUpText0: "Convierte todas las gemas de nivel 1 en gemas de nivel 2.",
    powerUpText1: "Convierte la próxima gema en una gema 123.",
    powerUpText2: "Reorganiza las gemas en el tablero.",
    powerUpText3: "Retrocede 20 movimientos.",
    ad: "Ver un anuncio para activar.",
    noAdsTitle: "No disponible",
    noAdsText: "No hay anuncios disponibles en este momento. Vuelva a intentarlo en unos segundos.",
    noInternetTitle: "Sin internet",
    noInternetText: "Asegúrate de estar conectado a Internet.",
    adBlockerTitle: "Bloqueador de anuncios",
    adBlockerText: "Desactive su bloqueador de anuncios y actualice la página.",
    oopsTitle: "Ups",
    oopsText: "Algo salió mal. Vuelva a intentarlo en unos segundos.",
    share: "¡Juega Gem·11!",
    shareScore: "Obtuve [0] puntos en la Gema 11. ¿Puedes vencerme? ¡Juega en POKI!"
  }; //Brazilian-Portugese

  localization.pt = {
    next: "próxima",
    powerUpTitle0: "Progresso",
    powerUpTitle1: "Gema 123",
    powerUpTitle2: "Mudança",
    powerUpTitle3: "Reviver",
    powerUpText0: "Transforme todas as gemas de nível 1 em gemas de nível 2.",
    powerUpText1: "Transforme a próxima gema em uma gema 123.",
    powerUpText2: "Reorganize as gemas no tabuleiro.",
    powerUpText3: "Volte 20 movimentos.",
    ad: "Assista a um anúncio para ativar.",
    noAdsTitle: "Não disponível",
    noAdsText: "Nenhum anúncio está disponível no momento. Por favor, tente novamente em alguns segundos.",
    noInternetTitle: "Sem internet",
    noInternetText: "Verifique se você está conectado à Internet.",
    adBlockerTitle: "Bloqueador de propagandas",
    adBlockerText: "Desative seu bloqueador de anúncios e atualize a página.",
    oopsTitle: "Ops",
    oopsText: "Algo deu errado. Por favor, tente novamente em alguns segundos.",
    share: "Jogue Gem·11!",
    shareScore: "Eu marquei [0] pontos na Joia 11. Você pode me vencer? Jogue no POKI!"
  }; //Russian

  localization.ru = {
    next: "следующий",
    powerUpTitle0: "Прогресс",
    powerUpTitle1: "Камень 123",
    powerUpTitle2: "Сдвиг",
    powerUpTitle3: "Возродить",
    powerUpText0: "Превратите все драгоценные камни 1-го уровня в драгоценные камни 2-го уровня.",
    powerUpText1: "Превратите грядущий драгоценный камень в 123-й драгоценный камень.",
    powerUpText2: "Переставьте драгоценные камни на доске.",
    powerUpText3: "Вернитесь на 20 ходов назад.",
    ad: "Посмотрите рекламу для активации.",
    noAdsTitle: "Нет в наличии",
    noAdsText: "В данный момент нет доступных объявлений. Повторите попытку через несколько секунд.",
    noInternetTitle: "Без интернета",
    noInternetText: "Убедитесь, что вы подключены к Интернету.",
    adBlockerTitle: "Блокировщик рекламы",
    adBlockerText: "Пожалуйста, отключите блокировщик рекламы и обновите страницу.",
    oopsTitle: "Упс",
    oopsText: "Что-то пошло не так. Повторите попытку через несколько секунд.",
    share: "Играть в Gem·11!",
    shareScore: "Я набрал [0] очков в Gem 11. Сможете ли вы победить меня? Играй на ПОКИ!"
  }; //Turkish

  localization.tr = {
    next: "sonraki",
    powerUpTitle0: "İlerlemek",
    powerUpTitle1: "Mücevher 123",
    powerUpTitle2: "Hareketli",
    powerUpTitle3: "Canlandırmak",
    powerUpText0: "Tüm 1. seviye taşları 2. seviye taşlara dönüştürün.",
    powerUpText1: "Yaklaşan mücevheri 123 mücevhere dönüştürün.",
    powerUpText2: "Tahtadaki mücevherleri yeniden düzenleyin.",
    powerUpText3: "Son 20 hamleni geri al.",
    ad: "Etkinleştirmek için bir reklam izleyin.",
    noAdsTitle: "Müsait değil",
    noAdsText: "Şu anda hiçbir reklam mevcut değil. Lütfen birkaç saniye içinde tekrar deneyin.",
    noInternetTitle: "İnternet yok",
    noInternetText: "İnternete bağlı olduğunuzdan emin olun.",
    adBlockerTitle: "Reklam engelleyici",
    adBlockerText: "Lütfen reklam engelleyicinizi devre dışı bırakın ve sayfayı yenileyin.",
    oopsTitle: "Hata",
    oopsText: "Bir şeyler yanlış gitti. Lütfen birkaç saniye içinde tekrar deneyin.",
    share: "Gem·11 oynayın!",
    shareScore: "Gem 11'de [0] puan aldım. Beni yenebilir misin? POKI'de oynayın!"
  }; //Chinese

  localization.zh = {
    next: "下一个",
    powerUpTitle0: "升级",
    powerUpTitle1: "宝石 123",
    powerUpTitle2: "换档",
    powerUpTitle3: "复活",
    powerUpText0: "将所有 1 级宝石变成 2 级宝石。",
    powerUpText1: "将即将到来的宝石变成 123 宝石。",
    powerUpText2: "重新排列板上的宝石。",
    powerUpText3: "返回 20 步。",
    ad: "观看广告以激活。",
    noAdsTitle: "无法使用",
    noAdsText: "目前没有可用的广告。 请在几秒钟后重试。",
    noInternetTitle: "没有互联网",
    noInternetText: "确保您已连接到 Internet。",
    adBlockerTitle: "广告拦截器",
    adBlockerText: "请禁用您的广告拦截器并刷新页面。",
    oopsTitle: "哎呀",
    oopsText: "出问题了。 请在几秒钟后重试。",
    share: "玩 Gem·11！",
    shareScore: "我在 Gem·11 中获得了 [0] 分。你能打败我吗 在 POKI 上玩！"
  }; //Japanese

  localization.ja = {
    next: "次",
    powerUpTitle0: "レベルアップ",
    powerUpTitle1: "ジェム123",
    powerUpTitle2: "シフティング",
    powerUpTitle3: "復活する",
    powerUpText0: "レベル 1 のジェムをすべてレベル 2 のジェムに変える。",
    powerUpText1: "次のジェムを 123 ジェムに変えます。",
    powerUpText2: "ボード上の宝石を並べ替えます。",
    powerUpText3: "最後の 20 の動きを元に戻します。",
    ad: "広告を見て有効にします。",
    noAdsTitle: "利用不可",
    noAdsText: "現在、利用できる広告はありません。 数秒後にもう一度お試しください。",
    noInternetTitle: "インターネットなし",
    noInternetText: "インターネットに接続していることを確認してください。",
    adBlockerTitle: "広告ブロッカー",
    adBlockerText: "広告ブロッカーを無効にして、ページを更新してください。",
    oopsTitle: "おっとっと",
    oopsText: "エラーが発生しました。 数秒後にもう一度お試しください。",
    share: "Gem・11で遊ぼう！",
    shareScore: "Gem・11 で [0] ポイントを獲得しました。勝てますか? POKIで遊ぼう！"
  }; //Korean

  localization.ko = {
    next: "다음",
    powerUpTitle0: "레벨 업",
    powerUpTitle1: "보석 123",
    powerUpTitle2: "이동",
    powerUpTitle3: "소생",
    powerUpText0: "모든 레벨 1 보석을 레벨 2 보석으로 바꿉니다.",
    powerUpText1: "다가오는 보석을 123개의 보석으로 바꾸세요.",
    powerUpText2: "보드에 보석을 재배열합니다.",
    powerUpText3: "마지막 20개 동작을 취소합니다.",
    ad: "활성화하려면 광고를 시청하세요.",
    noAdsTitle: "사용할 수 없습니다",
    noAdsText: "현재 사용할 수 있는 광고가 없습니다. 몇 초 후에 다시 시도하십시오.",
    noInternetTitle: "인터넷 없음",
    noInternetText: "인터넷에 연결되어 있는지 확인하십시오.",
    adBlockerTitle: "광고 차단기",
    adBlockerText: "광고 차단기를 비활성화하고 페이지를 새로고침하세요.",
    oopsTitle: "죄송합니다",
    oopsText: "문제가 발생했습니다. 몇 초 후에 다시 시도하십시오.",
    share: "Gem·11 을 플레이하세요!",
    shareScore: "Gem·11 에서 [0] 점을 얻었습니다. 나를 이길 수 있습니까? 포키에서 플레이하세요!"
  };
  var levels = []; //v= value;
  //l= level;

  levels.push({
    matrix: [[{
      v: 1,
      l: 0
    }, {
      v: 1,
      l: 0
    }, {
      v: 3,
      l: 0
    }], [{
      v: 2,
      l: 0
    }, {
      v: 1,
      l: 0
    }, {
      v: 1,
      l: 0
    }], [{
      v: 1,
      l: 0
    }, {
      v: 1,
      l: 0
    }, {
      v: 2,
      l: 0
    }], [{
      v: 1,
      l: 0
    }, {
      v: 2,
      l: 0
    }, {
      v: 1,
      l: 0
    }]]
  }); //settings

  var DEFAULT_BUTTON = {
    textStyle: new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 32,
      fill: ["#000000"],
      align: "center"
    }),
    hoverTextStyle: new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 32,
      fill: ["#000000"],
      align: "center"
    }),
    disabledTextStyle: new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 32,
      fill: ["#AAAAAA"],
      align: "center"
    }),
    selectedTextStyle: new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 32,
      fill: ["#000000"],
      align: "center"
    }),
    width: 200,
    height: 100,
    yOffset: 0,
    borderRadius: 300,
    hitAreaX: 1.25,
    hitAreaY: 1.25,
    imgHeight: 50,
    fadeDuration: 200,
    clickSound: "btnClick",
    fill1: [0xffffff, 0],
    fill2: [0xffffff, 0],
    line1: [0, 0x000000, 0],
    line2: [0, 0x000000, 0],
    imgColor: [0xffffff, 1],
    hoverFill1: [0x000000, 0.05],
    hoverFill2: [0x000000, 0],
    hoverLine1: [0, 0x000000, 0],
    hoverLine2: [0, 0x000000, 0],
    hoverImgColor: [0xffffff, 1],
    disabledFill1: [0x555555, 0],
    disabledFill2: [0x000000, 0],
    disabledLine1: [0, 0xdddddd, 0],
    disabledLine2: [0, 0x000000, 0],
    disabledImgColor: [0xffffff, 1],
    selectedFill1: [0xeeeeee, 0],
    selectedFill2: [0xcccccc, 0],
    selectedLine1: [0, 0xffffff, 0],
    selectedLine2: [0, 0x000000, 0],
    selectedImgColor: [0xffffff, 1]
  };
  var ICON_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  ICON_BUTTON.width = 100;
  ICON_BUTTON.height = 100;
  var LANG_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  LANG_BUTTON.width = 90;
  LANG_BUTTON.height = 90;
  LANG_BUTTON.imgHeight = 75;
  var PU_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  PU_BUTTON.yOffset = 5;
  PU_BUTTON.fill1 = [0xf0f0f0, 1];
  PU_BUTTON.fill2 = [0xe0e0e0, 1];
  PU_BUTTON.hoverFill1 = [0xffffff, 1];
  PU_BUTTON.hoverFill2 = [0xeeeeee, 1];
  PU_BUTTON.disabledFill1 = [0x000000, 0.05];
  PU_BUTTON.disabledImgColor = [0xffffff, 0.25];
  PU_BUTTON.width = 350;
  PU_BUTTON.height = 100;
  PU_BUTTON.imgHeight = 75;
  var TEXT_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  TEXT_BUTTON.width = 150;
  var PLAY_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  PLAY_BUTTON.width = 300;
  PLAY_BUTTON.height = 300;
  PLAY_BUTTON.imgHeight = 180;
  var LOADING_BUTTON = JSON.parse(JSON.stringify(PLAY_BUTTON));
  LOADING_BUTTON.imgColor = [0xffffff, 0.9];
  LOADING_BUTTON.hoverImgColor = [0xffffff, 1];
  LOADING_BUTTON.fill1 = [0xffffff, 1];
  LOADING_BUTTON.hoverFill1 = [0xffffff, 1];
  var SHIFT_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  SHIFT_BUTTON.width = 125;
  SHIFT_BUTTON.height = 125;
  SHIFT_BUTTON.imgHeight = 33;
  SHIFT_BUTTON.hitAreaX = 1.5, SHIFT_BUTTON.hitAreaY = 1.5;
  var RESTART_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  RESTART_BUTTON.width = 200;
  RESTART_BUTTON.height = 200;
  RESTART_BUTTON.imgHeight = 100;
  var POPUP_BUTTON = JSON.parse(JSON.stringify(DEFAULT_BUTTON));
  POPUP_BUTTON.width = 275;
  POPUP_BUTTON.height = 70; ///////////////////////////
  //button class

  function Button(parent, textKey, img, callback, style, keys) {
    var yOffset = 10;
    var btn = new Container(parent);
    style = style || DEFAULT_BUTTON;

    if (Array.isArray(textKey)) {
      btn.textList = textKey;
      btn.currentTextIndex = 0;
      textKey = textKey[0];
    }

    if (Array.isArray(img)) {
      btn.imgList = img;
      btn.currentImgIndex = 0;
      img = img[0];
    }

    var text = textKey;

    if (getText(textKey)) {
      btn.textKey = textKey;
      text = getText(textKey);
    }

    btn.style = style;
    btn.callback = callback;

    if (keys) {
      btn.keys = keys;
      keyboardControls.addButton(btn);
    }

    btn.transparent = new WhiteRectangle(btn, [style.width * style.hitAreaX, (style.height + style.yOffset) * style.hitAreaY]);
    btn.transparent.alpha = 0;
    btn.backRect = new Rectangle(btn, [style.width, style.height + style.yOffset, style.borderRadius]);
    btn.backRect.tint = style.fill2[0];
    btn.backRect.alpha = style.fill2[1];
    btn.backLine = new Rectangle(btn, [style.width, style.height + style.yOffset, style.borderRadius], [style.line2[0], 0xffffff, 1], [0xffffff, 0]);
    btn.backLine.tint = style.line2[1];
    btn.backLine.alpha = style.line2[2];
    btn.frontRect = new Rectangle(btn, [style.width, style.height, style.borderRadius]);
    btn.frontRect.y = -style.yOffset * 0.5;
    btn.frontRect.tint = style.fill1[0];
    btn.frontRect.alpha = style.fill1[1];
    btn.frontLine = new Rectangle(btn, [style.width, style.height, style.borderRadius], [style.line1[0], 0xffffff, 1], [0xffffff, 0]);
    btn.frontLine.y = -style.yOffset * 0.5;
    btn.frontLine.tint = style.line1[1];
    btn.frontLine.alpha = style.line1[2];
    btn.frontRect.startY = btn.frontRect.y;
    btn.frontRect.downY = btn.frontRect.y + style.yOffset;
    btn.textBox = new Text(btn, text, style.textStyle), btn.textBox.y = -style.yOffset * 0.5;
    btn.textBox.startY = btn.textBox.y;
    btn.textBox.downY = btn.textBox.y + style.yOffset;

    if (img) {
      btn.img = new Sprite(btn, img);
      btn.img.position.set(0, -style.yOffset * 0.5);
      btn.img.anchor.set(0.5);
      var ratio = btn.img.width / btn.img.height;
      btn.img.height = style.imgHeight;
      btn.img.width = style.imgHeight * ratio;
      btn.img.tint = style.imgColor[0];
      btn.img.alpha = style.imgColor[1];
      btn.img.startY = btn.img.y;
      btn.img.downY = btn.img.y + style.yOffset;

      if (text) {
        btn.img.x = -style.width * 0.5 + btn.img.width * 0.5 + (style.height - btn.img.height) * 0.5;
        btn.textBox.anchor.set(0, 0.5);
        btn.textBox.x = btn.img.x + btn.img.width * 0.5 + (style.height - btn.img.height) * 0.5; //((style.height - btn.img.height) * 0.5 + btn.img.width) * 0.5;
      }
    }

    btn.interactive = true;
    btn.buttonMode = true;
    btn.isPressed = false;

    btn.disable = function () {
      btn.interactive = false;
      fadeToColor(btn.frontRect, btn.style.disabledFill1[0], btn.style.disabledFill1[1], btn.style.fadeDuration);
      fadeToColor(btn.frontLine, btn.style.disabledLine1[1], btn.style.disabledLine1[2], btn.style.fadeDuration);
      fadeToColor(btn.backRect, btn.style.disabledFill2[0], btn.style.disabledFill2[1], btn.style.fadeDuration);
      fadeToColor(btn.backLine, btn.style.disabledLine2[1], btn.style.disabledLine2[2], btn.style.fadeDuration);
      btn.textBox.style = btn.style.disabledTextStyle;

      if (btn.img) {
        fadeToColor(btn.img, btn.style.disabledImgColor[0], btn.style.disabledImgColor[1], btn.style.fadeDuration);
      }
    };

    btn.enable = function () {
      btn.interactive = true;
      fadeToColor(btn.frontRect, btn.style.fill1[0], btn.style.fill1[1], btn.style.fadeDuration);
      fadeToColor(btn.frontLine, btn.style.line1[1], btn.style.line1[2], btn.style.fadeDuration);
      fadeToColor(btn.backRect, btn.style.fill2[0], btn.style.fill2[1], btn.style.fadeDuration);
      fadeToColor(btn.backLine, btn.style.line2[1], btn.style.line2[2], btn.style.fadeDuration);
      btn.textBox.style = btn.style.textStyle;

      if (btn.img) {
        fadeToColor(btn.img, btn.style.imgColor[0], btn.style.imgColor[1], btn.style.fadeDuration);
      }
    };

    btn.setText = function (newText) {
      if (getText(newText)) {
        btn.textKey = newText;
        newText = getText(newText);
      }

      btn.textBox.text = newText;
    };

    btn.setImg = function (newTexture) {
      if (!btn.img) return;
      if (PIXI.utils.TextureCache[newTexture]) btn.img.texture = PIXI.utils.TextureCache[newTexture];else btn.img.texture = PIXI.Texture.fromImage(newTexture);
      btn.img.scale.set(1);
      var ratio = btn.img.width / btn.img.height;
      btn.img.height = style.imgHeight;
      btn.img.width = style.imgHeight * ratio;
    };

    btn.onPointerDown = function (e) {
      btn.isPressed = true;
      btn.frontRect.y = btn.frontRect.downY;
      btn.frontLine.y = btn.frontRect.downY;
      btn.textBox.y = btn.textBox.downY;

      if (btn.img) {
        btn.img.y = btn.img.downY;
      }
    };

    btn.on("pointerdown", btn.onPointerDown);

    btn.onMouseUp = function (e) {
      if (!btn.isPressed) return;
      if (btn.group != undefined) return;
      if (btn.callback) btn.callback(e);
      if (btn.style.clickSound) playSound(btn.style.clickSound);
      btn.isPressed = false;
      btn.frontRect.y = btn.frontRect.startY;
      btn.frontLine.y = btn.frontRect.startY;
      btn.textBox.y = btn.textBox.startY;
      fadeToColor(btn.frontRect, btn.style.hoverFill1[0], btn.style.hoverFill1[1], btn.style.fadeDuration);
      fadeToColor(btn.frontLine, btn.style.hoverLine1[1], btn.style.hoverLine1[2], btn.style.fadeDuration);
      fadeToColor(btn.backRect, btn.style.hoverFill2[0], btn.style.hoverFill2[1], btn.style.fadeDuration);
      fadeToColor(btn.backLine, btn.style.hoverLine2[1], btn.style.hoverLine2[2], btn.style.fadeDuration);
      btn.textBox.style = btn.style.hoverTextStyle;

      if (btn.img) {
        btn.img.y = btn.img.startY;
        fadeToColor(btn.img, btn.style.hoverImgColor[0], btn.style.hoverImgColor[1], btn.style.fadeDuration);
      }

      if (btn.textList) {
        btn.currentTextIndex = (btn.currentTextIndex + 1) % btn.textList.length;
        btn.setText(btn.textList[btn.currentTextIndex]);
      }

      if (btn.imgList) {
        btn.currentImgIndex = (btn.currentImgIndex + 1) % btn.imgList.length;
        btn.setImg(btn.imgList[btn.currentImgIndex]);
      }
    };

    btn.on("mouseup", btn.onMouseUp);

    btn.onTouchEnd = function (e) {
      if (!btn.isPressed) return;
      if (btn.group != undefined) return;
      if (btn.callback) btn.callback(e);
      if (btn.style.clickSound) playSound(btn.style.clickSound);
      btn.isPressed = false;
      btn.frontRect.y = btn.frontRect.startY;
      btn.frontLine.y = btn.frontRect.startY;
      btn.textBox.y = btn.textBox.startY;

      if (btn.img) {
        btn.img.y = btn.img.startY;
      }

      if (btn.textList) {
        btn.currentTextIndex = (btn.currentTextIndex + 1) % btn.textList.length;
        btn.setText(btn.textList[btn.currentTextIndex]);
      }

      if (btn.imgList) {
        btn.currentImgIndex = (btn.currentImgIndex + 1) % btn.imgList.length;
        btn.setImg(btn.imgList[btn.currentImgIndex]);
      }
    };

    btn.on("touchend", btn.onTouchEnd);

    btn.onTouchOutside = function (e) {
      btn.isPressed = false;
      btn.frontRect.y = btn.frontRect.startY;
      btn.frontLine.y = btn.frontRect.startY;
      btn.textBox.y = btn.textBox.startY;

      if (btn.img) {
        btn.img.y = btn.img.startY;
      }
    };

    btn.on("touchendoutside", btn.onTouchOutside);

    btn.onMouseOver = function (e) {
      fadeToColor(btn.frontRect, btn.style.hoverFill1[0], btn.style.hoverFill1[1], btn.style.fadeDuration);
      fadeToColor(btn.frontLine, btn.style.hoverLine1[1], btn.style.hoverLine1[2], btn.style.fadeDuration);
      fadeToColor(btn.backRect, btn.style.hoverFill2[0], btn.style.hoverFill2[1], btn.style.fadeDuration);
      fadeToColor(btn.backLine, btn.style.hoverLine2[1], btn.style.hoverLine2[2], btn.style.fadeDuration);
      btn.textBox.style = btn.style.hoverTextStyle;

      if (btn.img) {
        btn.img.y = btn.img.startY;
        fadeToColor(btn.img, btn.style.hoverImgColor[0], btn.style.hoverImgColor[1], btn.style.fadeDuration);
      }
    };

    btn.on("mouseover", btn.onMouseOver);

    btn.onMouseOut = function (e) {
      btn.isPressed = false;
      btn.frontRect.y = btn.frontRect.startY;
      btn.frontLine.y = btn.frontRect.startY;
      btn.textBox.y = btn.textBox.startY;
      fadeToColor(btn.frontRect, btn.style.fill1[0], btn.style.fill1[1], btn.style.fadeDuration);
      fadeToColor(btn.frontLine, btn.style.line1[1], btn.style.line1[2], btn.style.fadeDuration);
      fadeToColor(btn.backRect, btn.style.fill2[0], btn.style.fill2[1], btn.style.fadeDuration);
      fadeToColor(btn.backLine, btn.style.line2[1], btn.style.line2[2], btn.style.fadeDuration);
      btn.textBox.style = btn.style.textStyle;

      if (btn.img) {
        fadeToColor(btn.img, btn.style.imgColor[0], btn.style.imgColor[1], btn.style.fadeDuration);
        btn.img.y = btn.img.startY;
      }
    };

    btn.on("mouseout", btn.onMouseOut);
    btn.type = "Button";

    btn["delete"] = function () {
      var elLength = btn.children.length;

      for (var i = elLength - 1; i >= 0; i--) {
        btn.children[i]["delete"]();
      }

      btn.off("mouseout", btn.onMouseOut);
      btn.off("mouseover", btn.onMouseOver);
      btn.off("touchendoutside", btn.onTouchOutside);
      btn.off("touchend", btn.onTouchEnd);
      btn.off("mouseup", btn.onMouseUp);
      btn.off("pointerdown", btn.onPointerDown);

      if (btn.onPointerUp) {
        btn.off("pointerup", btn.onPointerUp);
      }

      if (btn.keys) {
        keyboardControls.removeButton(btn);
      }

      parent.removeChild(btn);
      btn.destroy();
      btn = null;
    };

    btn.getName = function () {
      var str = btn.type;
      if (btn.textBox) str += " - " + btn.textBox.text;

      if (btn.img) {
        str += " - " + btn.img.texture.textureCacheIds[0];
      }

      return str;
    };

    return btn;
  } //SpriteButton class
  //required: parrent, callback, img (+ "_default.png", "_hover.png", "_pressed.png", "_disabled.png")
  //optional: elastic(def: false), hitArea(def: [1, 1]);
  //


  function SpriteButton(parent, callback, img, elastic, hitArea, keys) {
    elastic = elastic || false;
    hitArea = hitArea || [1, 1];
    hitArea[1] = hitArea[1] || hitArea[0];
    var t = new Container(parent);
    t.type = "Button";
    t.elastic = elastic;
    t.callback = callback;

    if (keys) {
      t.keys = keys;
      keyboardControls.addButton(t);
    }

    t.isPressed = false;

    if (PIXI.utils.TextureCache[img + "_default.png"] != undefined) {
      t.defaultTexture = PIXI.utils.TextureCache[img + "_default.png"];
      t.hoverTexture = PIXI.utils.TextureCache[img + "_hover.png"];
      t.pressedTexture = PIXI.utils.TextureCache[img + "_pressed.png"];
      t.disabledTexture = PIXI.utils.TextureCache[img + "_disabled.png"];
      var b = new Sprite(t, img + "_default.png");
    } else {
      t.defaultTexture = PIXI.utils.TextureCache[img];
      t.hoverTexture = PIXI.utils.TextureCache[img];
      t.pressedTexture = PIXI.utils.TextureCache[img];
      t.disabledTexture = PIXI.utils.TextureCache[img];
      var b = new Sprite(t, img);
    } //hit area


    var wr = new WhiteRectangle(t, [b.width * hitArea[0], b.height * hitArea[1]]);
    wr.alpha = 0;
    t.addChild(wr);
    t.interactive = true;
    t.buttonMode = true; //events

    t.onTouchEnd = function (e) {
      if (!t.isPressed) return;
      t.callback(e);
      t.isPressed = false;

      if (t.interactive) {
        b.pointerUpStarted = true;
        setTimeout(function () {
          b.texture = t.defaultTexture;

          if (t.elastic) {
            b.targetScale = 1;

            if (b.poinerDownEnded) {
              TweenMax.to(b, 0.3, {
                pixi: {
                  scale: b.targetScale
                },
                ease: Elastic.easeOut.config(1, 0.45)
              });
            }
          }
        }, 50);
      }
    };

    t.on("touchend", t.onTouchEnd);

    t.onTouchOutside = function () {
      t.isPressed = false;

      if (t.interactive) {
        setTimeout(function () {
          b.texture = t.defaultTexture;

          if (t.elastic) {
            TweenMax.to(b, 0.1, {
              pixi: {
                scale: 1
              },
              ease: Elastic.easeOut.config(1, 0.45)
            });
          }
        }, 50);
      }
    };

    t.on("touchendoutside", t.onTouchOutside);

    t.onMouseUp = function (e) {
      if (!t.isPressed) return;
      t.callback(e);
      t.isPressed = false;

      if (t.interactive) {
        b.pointerUpStarted = true;
        setTimeout(function () {
          b.texture = t.hoverTexture;

          if (t.elastic) {
            b.targetScale = 1.05;

            if (b.poinerDownEnded) {
              TweenMax.to(b, 0.3, {
                pixi: {
                  scale: b.targetScale
                },
                ease: Elastic.easeOut.config(1, 0.45)
              });
            }
          }
        }, 50);
      }
    };

    t.on("mouseup", t.onMouseUp);

    t.onPointerDown = function () {
      b.texture = t.pressedTexture;
      t.isPressed = true;

      if (t.elastic) {
        b.poinerDownEnded = false;
        b.pointerUpStarted = false;
        TweenMax.to(b, 0.1, {
          pixi: {
            scale: 0.95
          },
          onComplete: function onComplete() {
            b.poinerDownEnded = true;

            if (b.pointerUpStarted) {
              TweenMax.to(b, 0.3, {
                pixi: {
                  scale: b.targetScale
                },
                ease: Elastic.easeOut.config(1, 0.45)
              });
            }
          }
        });
      }
    };

    t.on("pointerdown", t.onPointerDown);

    t.onMouseOver = function () {
      b.texture = t.hoverTexture;

      if (t.elastic) {
        TweenMax.to(b, 0.5, {
          pixi: {
            scale: 1.05
          },
          ease: Elastic.easeOut.config(1, 0.45)
        });
      }
    };

    t.on("mouseover", t.onMouseOver);

    t.onMouseOut = function () {
      b.texture = t.defaultTexture;
      t.isPressed = false;

      if (t.elastic) {
        TweenMax.to(b, 0.1, {
          pixi: {
            scale: 1
          }
        });
      }
    };

    t.on("mouseout", t.onMouseOut);
    parent.addChild(t); //methods

    t.disable = function () {
      t.interactive = false;
      setTimeout(function () {
        b.texture = t.disabledTexture;

        if (t.elastic) {
          b.scale.set(1);
        }
      }, 50);
    };

    t.enable = function () {
      t.interactive = true;
      setTimeout(function () {
        b.texture = t.defaultTexture;

        if (t.elastic) {
          b.scale.set(1);
        }
      }, 50);
    };

    t.getName = function () {
      return t.type + " - " + t.defaultTexture.textureCacheIds[0];
    };

    t["delete"] = function () {
      var elLength = t.children.length;

      for (var i = elLength - 1; i >= 0; i--) {
        t.children[i]["delete"]();
      }

      t.off("mouseout", t.onMouseOut);
      t.off("mouseover", t.onMouseOver);
      t.off("touchendoutside", t.onTouchOutside);
      t.off("touchend", t.onTouchEnd);
      t.off("mouseup", t.onMouseUp);
      t.off("pointerdown", t.onPointerDown);

      if (t.onPointerUp) {
        t.off("pointerup", t.onPointerUp);
      }

      if (t.keys) {
        keyboardControls.removeButton(t);
      }

      parent.removeChild(t);
      t.destroy();
      t = null;
    };

    return t;
  } //ButtonGroup class


  function ButtonGroup(arrayOfButtons, initSelection) {
    arrayOfButtons = arrayOfButtons || [];
    if (initSelection == undefined) initSelection = -1;
    var bg = {};
    bg.list = [];
    if (arrayOfButtons.length > 0 && initSelection) bg.selectedButton = arrayOfButtons[initSelection];
    bg.selectedIndex = initSelection;

    bg.addButton = function (button) {
      bg.list.push(button);
      button.group = bg;

      button.onPointerUp = function (e) {
        if (!button.isPressed && e != null) return;
        var t = button;

        for (var i = 0; i < t.group.list.length; i++) {
          var btn = t.group.list[i];
          if (btn == t) continue;
          btn.interactive = true;
          btn.frontRect.y = btn.frontRect.startY;
          btn.textBox.y = btn.textBox.startY;
          btn.textBox.style = btn.style.textStyle;
          fadeToColor(btn.frontRect, btn.style.fill1[0], btn.style.fill1[1], btn.style.fadeDuration);
          fadeToColor(btn.frontLine, btn.style.line1[1], btn.style.line1[2], btn.style.fadeDuration);
          fadeToColor(btn.backRect, btn.style.fill2[0], btn.style.fill2[1], btn.style.fadeDuration);
          fadeToColor(btn.backLine, btn.style.line2[1], btn.style.line2[2], btn.style.fadeDuration);
          btn.textBox.style = btn.style.textStyle;

          if (btn.img) {
            fadeToColor(btn.img, btn.style.imgColor[0], btn.style.imgColor[1], btn.style.fadeDuration);
            btn.img.y = btn.img.startY;
          }
        }

        t.group.selectedButton = t;
        t.group.selectedIndex = t.group.list.indexOf(t);
        t.interactive = false;
        if (t.callback) t.callback(e);
        t.frontRect.y = t.frontRect.downY;
        t.textBox.y = t.textBox.downY;
        t.textBox.style = t.style.selectedTextStyle;
        fadeToColor(t.frontRect, t.style.selectedFill1[0], t.style.selectedFill1[1], t.style.fadeDuration);
        fadeToColor(t.frontLine, t.style.selectedLine1[1], t.style.selectedLine1[2], t.style.fadeDuration);
        fadeToColor(t.backRect, t.style.selectedFill2[0], t.style.selectedFill2[1], btn.style.fadeDuration);
        fadeToColor(t.backLine, t.style.selectedLine2[1], t.style.selectedLine2[2], t.style.fadeDuration);

        if (t.img) {
          fadeToColor(btn.img, btn.style.selectedImgColor[0], btn.style.selectedImgColor[1], btn.style.fadeDuration);
          t.img.y = t.img.downY;
        }
      };

      button.on("pointerup", button.onPointerUp);
    };

    bg.removeButton = function (button) {
      bg.list.splice(bg.list.indexOf(button), 1);
      button.off("pointerup", button.onPointerUp);
      button.group = null;
      button.onPointerUp = null;
      bg.selectedIndex = bg.list.indexOf(bg.selectedButton);
      if (button == bg.selectedButton) bg.selectedButton = null;
    };

    for (var i = 0; i < arrayOfButtons.length; i++) {
      bg.addButton(arrayOfButtons[i]);
    }

    if (initSelection > -1) arrayOfButtons[initSelection].onPointerUp();
    return bg;
  }

  var activePopup; //settings

  var DEFAULT_POPUP = {
    titleStyle: new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 42,
      fill: ["#000000"],
      align: "center"
    }),
    textStyle: new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 36,
      fill: ["#000000"],
      align: "center",
      wordWrap: true,
      wordWrapWidth: 520
    }),
    scrollTextStyle: new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 36,
      fill: ["#000000"],
      align: "left",
      wordWrap: true,
      wordWrapWidth: 520
    }),
    width: 1000,
    height: 1000,
    titleHeight: 0,
    borderRadius: 0,
    padding: 20,
    overlayFill: [0xffffff, 0.99],
    titleBgFill: [primaryPalette[1], 0],
    textBgFill: [0xffffff, 0],
    scrollBarFill: [primaryPalette[1], 0.1],
    closeBgFill: [0x000000, 0],
    closeBgHoverFill: [0x000000, 0],
    closeBgDownFill: [0x000000, 0],
    closeIconFill: [0x000000, 0],
    openAnimation: function openAnimation(popup) {
      popup.overlay.alpha = 0;
      TweenMax.to(popup.overlay, 0.3, {
        pixi: {
          alpha: popup.style.overlayFill[1]
        }
      }); //popup.window.y = -APP.screen.height * 0.5 - popup.window.height * 0.5;

      popup.content.alpha = 0;
      popup.content.scale.set(0.75);
      TweenMax.to(popup.content, 0.5, {
        pixi: {
          //y: 0
          alpha: 1,
          scale: 1
        },
        ease: Elastic.easeOut.config(1, 1),
        delay: 0.2
      });
    },
    closeAnimation: function closeAnimation(popup) {
      TweenMax.to(popup.overlay, 0.5, {
        pixi: {
          alpha: 0
        },
        delay: 0.2,
        ease: Power2.easeIn,
        onComplete: function onComplete() {
          activePopup = null;
          popup["delete"]();

          if (popup.closeCallback) {
            popup.closeCallback();
          }
        }
      });
      TweenMax.to(popup.content, 0.5, {
        pixi: {
          //y: -APP.screen.height * 0.5 - popup.window.height * 0.5
          alpha: 0,
          scale: 0.75
        },
        ease: Elastic.easeIn.config(1, 1)
      });
    }
  };
  var SMALL_POPUP = JSON.parse(JSON.stringify(DEFAULT_POPUP));
  SMALL_POPUP.height = 300;
  var LARGE_POPUP = JSON.parse(JSON.stringify(DEFAULT_POPUP));
  LARGE_POPUP.height = 900; ///////////////////

  function alertPopup(titleKey, textKey, onCloseCallback, style) {
    var popup = new Container(APP.stage);
    style = style || DEFAULT_POPUP;
    popup.style = style;
    popup.closeCallback = onCloseCallback;
    var title = getText(titleKey) || titleKey;
    var text = getText(textKey) || textKey;
    popup.overlay = new WhiteRectangle(popup, [APP.screen.width, APP.screen.height]);
    popup.overlay.tint = style.overlayFill[0];
    popup.overlay.alpha = style.overlayFill[1];
    popup.overlay.interactive = true;
    popup.window = new Container(popup);
    popup.textBoxBg = new Rectangle(popup.window, [style.width, style.height, style.borderRadius], [0, 0], [0xffffff, 1]);
    popup.textBoxBg.tint = style.textBgFill[0];
    popup.textBoxBg.alpha = style.textBgFill[1];
    popup.content = new Container(popup.window);
    popup.textBox = new Text(popup.content, text, style.textStyle);
    popup.textBox.position.set(0, style.titleHeight / 2);

    if (popup.content.height > style.height - style.titleHeight) {
      popup.textBox.style = style.scrollTextStyle;
      popup.textBox.anchor.set(0.5, 0);
      popup.textBox.y = -style.height * 0.5 + style.titleHeight + style.padding + style.borderRadius / 2;
      popup.contentMask = new WhiteRectangle(popup.window, [style.width, style.height - style.titleHeight - (style.borderRadius + 4)]);
      popup.contentMask.anchor.set(0);
      popup.contentMask.setTransform(-style.width / 2, -style.height / 2 + style.titleHeight + (style.borderRadius + 4) / 2);
      makeScrollable(popup.content, popup.contentMask, style.padding * 2, style.scrollBarFill[0]);
      popup.content.scrollBar.alpha = style.scrollBarFill[1];
    }

    popup.titleMask = new Rectangle(popup.window, [style.width, style.height, style.borderRadius], null, null, true);
    popup.titleMask.anchor.set(0);
    popup.titleMask.position.set(-style.width / 2, -style.height / 2);
    popup.titleBg = new Rectangle(popup.window, [style.width, style.titleHeight]);
    popup.titleBg.y = -(style.height - style.titleHeight) * 0.5;
    popup.titleBg.tint = style.titleBgFill[0];
    popup.titleBg.alpha = style.titleBgFill[1];
    popup.titleBg.mask = popup.titleMask;
    popup.closeBg = new Rectangle(popup.window, [style.titleHeight, style.titleHeight]);
    popup.closeBg.position.set((style.width - style.titleHeight) * 0.5, -(style.height - style.titleHeight) * 0.5);
    popup.closeBg.tint = style.closeBgFill[0];
    popup.closeBg.alpha = style.closeBgFill[1];
    popup.closeBg.mask = popup.titleMask;
    popup.titleText = new Text(popup.window, title, style.titleStyle);
    popup.titleText.position.set(0, -style.height / 2 + style.titleHeight / 2);
    popup.closeIcon = new Container(popup.window);
    var line1 = new Rectangle(popup.closeIcon, [4, style.titleHeight * 0.66, 0], [0], [0xffffff, 1]);
    line1.position = popup.closeBg.position;
    line1.rotation = degToRad(45);
    var line2 = new Rectangle(popup.closeIcon, [4, style.titleHeight * 0.66, 0], [0], [0xffffff, 1]);
    line2.position = popup.closeBg.position;
    line2.rotation = degToRad(-45);
    line1.tint = style.closeIconFill[0];
    line1.alpha = style.closeIconFill[1];
    line2.tint = style.closeIconFill[0];
    line2.alpha = style.closeIconFill[1];
    makeInteractive(popup.closeBg, "pointerup", function () {
      popup.closeBg.tint = style.closeBgFill[0];
      popup.closeBg.alpha = style.closeBgFill[1];
      line1.scale.set(1);
      line2.scale.set(1);
      popup.closeBg.interactive = false;
      closePopup();
    });
    makeInteractive(popup.closeBg, "mouseover", function () {
      popup.closeBg.tint = style.closeBgHoverFill[0];
      popup.closeBg.alpha = style.closeBgHoverFill[1];
    });
    makeInteractive(popup.closeBg, "mouseout", function () {
      popup.closeBg.tint = style.closeBgFill[0];
      popup.closeBg.alpha = style.closeBgFill[1];
      line1.scale.set(1);
      line2.scale.set(1);
    });
    makeInteractive(popup.closeBg, "pointerdown", function () {
      popup.closeBg.tint = style.closeBgDownFill[0];
      popup.closeBg.alpha = style.closeBgDownFill[1];
      line1.scale.set(0.95);
      line2.scale.set(0.95);
    });
    if (popup.style.openAnimation) popup.style.openAnimation(popup);
    activePopup = popup;
    resizePopup();
    return popup;
  }

  function confirmPopup(titleKey, textKey, btnTexts, callbacks, style, buttonStyle) {
    style = style || SMALL_POPUP;
    buttonStyle = buttonStyle || POPUP_BUTTON;
    var popup = alertPopup(titleKey, textKey, null, style);

    function f(i) {
      callbacks[i]();
      popup.buttons[0].interactive = false;
      popup.buttons[1].interactive = false;
      closePopup();
    }

    popup.buttons = [];
    popup.buttons[0] = new Button(popup.content, btnTexts[0], "", function () {
      f(0);
    }, buttonStyle);
    popup.buttons[1] = new Button(popup.content, btnTexts[1], "", function () {
      f(1);
    }, buttonStyle);
    var buttonPadding = (popup.style.width - 2 * buttonStyle.width) / 3;
    popup.buttons[0].x = -buttonPadding / 2 - buttonStyle.width / 2;
    popup.buttons[1].x = buttonPadding / 2 + buttonStyle.width / 2;

    if (!popup.content.scrollable) {
      popup.buttons[0].y = popup.style.height * 0.5 - popup.buttons[0].height * 0.5 - buttonPadding;
      popup.buttons[1].y = popup.style.height * 0.5 - popup.buttons[0].height * 0.5 - buttonPadding;
      popup.textBox.y -= (popup.buttons[0].height + 20) * 0.5;
    } else {
      var btnY = popup.content.height;
      popup.buttons[0].y = btnY;
      popup.buttons[1].y = btnY;
      updateScroll(popup.content, popup.contentMask, style.padding * 2);
    }

    return popup;
  }

  function closePopup() {
    if (!activePopup) return;
    var popup = activePopup;

    if (popup.style.closeAnimation) {
      popup.style.closeAnimation(popup);
    } else {
      activePopup = null;
      popup["delete"]();
    }
  }

  function resizePopup() {
    if (activePopup != undefined) {
      activePopup.overlay.width = APP.screen.width;
      activePopup.overlay.height = APP.screen.height;
      activePopup.position.set(APP.screen.width / 2, APP.screen.height / 2);
      activePopup.window.scale.set(ratio_scale);
    }
  }

  resize_methods.push(resizePopup);
  var wasDragging_bool = false;
  var scrollEventAdded_bool = false;
  var scrollSensitivity_num = 1;
  var currentScrollable_object;
  var oldMousePos, newMousePos, oldMouseTime, newMouseTime, startMouseTime, startMousePos;
  var minDragTime = 100; //miliseconds

  var minDragSpace = 10; // SCROLL INIT

  function makeScrollable(obj, mask, bottomMargine, scrollBarColor) {
    obj.scrollable = true;
    makeInteractive(mask, "pointerdown", onScrollPointerDown);
    makeInteractive(mask, "pointerup", onScrollPointerUp);
    makeInteractive(mask, "pointerupoutside", onScrollPointerUpOutside);
    makeInteractive(mask, "pointermove", onScrollPointerMove);
    makeInteractive(mask, "pointerover", onScrollPointerOver);
    makeInteractive(mask, "pointerout", onScrollPointerOut);

    if (bottomMargine == undefined) {
      bottomMargine = 0;
    }

    scrollBarColor = scrollBarColor || 0x000000;
    obj.minY = obj.y;
    obj.maxY = obj.y - obj.height + mask.height - bottomMargine; //add scroll bar

    var barX = mask.x - mask.anchor.x * mask.width + mask.width - 10;
    var barY = mask.y - mask.anchor.y * mask.height;
    obj.scrollBar = new Rectangle(mask.parent, [6, mask.height * mask.height / obj.height]);
    obj.scrollBar.position.set(barX, barY);
    obj.scrollBar.anchor.set(0);
    obj.scrollBar.tint = scrollBarColor;
    obj.scrollBar.maxY = barY + mask.height - obj.scrollBar.height;
    obj.scrollBar.minY = barY;
    obj.mask = mask;
    obj.scrollBar.mask = mask;
    mask.masked = obj;

    if (!scrollEventAdded_bool) {
      scrollEventAdded_bool = true;
      APP.view.addEventListener('mousewheel', onScrollMouseWheel);
    }

    enableScroll(obj, mask, true);
  } // ENABLE SCROLL


  function enableScroll(obj, mask, boolVal) {
    mask.interactive = boolVal;
    mask.buttonMode = boolVal;

    for (var i = 0; i < obj.children.length; i++) {
      if (obj.getChildAt(i).onPointerUp != undefined) {
        obj.getChildAt(i).interactive = boolVal;
      }
    }

    if (obj.scrollBar != undefined) {
      obj.scrollBar.visible = boolVal;
    }

    if (!boolVal) {
      currentScrollable_object = null;
    }
  }

  function updateScroll(obj, mask, bottomMargine) {
    if (obj.scrollAnim) obj.scrollAnim.kill();
    if (obj.textAnim) obj.textAnim.kill();
    obj.y = obj.minY;

    if (obj.height < mask.height) {
      enableScroll(obj, mask, false);
      return;
    } else {
      enableScroll(obj, mask, true);
    }

    bottomMargine = bottomMargine || 0;
    obj.maxY = obj.y - obj.height + mask.height - bottomMargine; //add

    var barX = mask.x - mask.anchor.x * mask.width + mask.width - 10;
    var barY = mask.y - mask.anchor.y * mask.height;
    var scrollBarColor = obj.scrollBar.tint;
    var scrollBarAlpha = obj.scrollBar.alpha;
    obj.scrollBar["delete"]();
    obj.scrollBar = new Rectangle(mask.parent, [6, mask.height * mask.height / obj.height]);
    obj.scrollBar.position.set(barX, barY);
    obj.scrollBar.anchor.set(0);
    obj.scrollBar.tint = scrollBarColor;
    obj.scrollBar.alpha = scrollBarAlpha;
    obj.scrollBar.maxY = barY + mask.height - obj.scrollBar.height;
    obj.scrollBar.minY = barY;
    obj.scrollBar.mask = mask;
  } // ON POINTER UP


  function onScrollPointerUp(e) {
    var obj = this.masked;
    obj.isScrolling = false;
    newMouseTime = new Date().getTime();
    newMousePos = e.data.getLocalPosition(this.parent);

    if (oldMousePos != undefined) {
      var duration = 0.75;
      var scrollSpeed = (newMousePos.y - oldMousePos.y) * scrollSensitivity_num * 3 / (newMouseTime - oldMouseTime);
      var textTargetY = obj.y + scrollSpeed * duration / 0.016;
      textTargetY = Math.min(Math.max(textTargetY, obj.maxY), obj.minY);
      var moveFactor = (textTargetY - obj.minY) / (obj.maxY - obj.minY);
      var scrollTargetY = obj.scrollBar.minY + (obj.scrollBar.maxY - obj.scrollBar.minY) * moveFactor;
      keepMoving(obj, duration, textTargetY, scrollTargetY);
      fixScroll(obj);
    }

    if (!wasDragging_bool) {
      var gl_pos = e.data.getLocalPosition(APP.stage);
      var child = PIXI.interaction.InteractionManager.prototype.hitTest(gl_pos, obj);

      if (child != undefined) {
        if (e.type == "tap" && child.onTouchEnd) {
          child.onTouchEnd(e);
        }

        if (e.type != "tap" && child.onMouseUp) {
          child.onMouseUp(e);
        }

        if (child.onPointerUp) {
          child.onPointerUp(e);
        }
      }
    }
  } // ON POINTER DOWN


  function onScrollPointerDown(e) {
    wasDragging_bool = false;
    var obj = this.masked;
    obj.isScrolling = true;
    newMousePos = e.data.getLocalPosition(this.parent);
    startMousePos = {
      x: newMousePos.x,
      y: newMousePos.y
    };
    newMouseTime = new Date().getTime();
    startMouseTime = newMouseTime;

    if (obj.textAnim != undefined) {
      obj.textAnim.kill();
      obj.scrollAnim.kill();
    }

    if (!wasDragging_bool) {
      var gl_pos = e.data.getLocalPosition(APP.stage);
      var child = PIXI.interaction.InteractionManager.prototype.hitTest(gl_pos, obj);

      if (child != undefined) {
        if (child.onPointerDown) {
          child.onPointerDown(e);
        }
      }
    }
  } // ON POINTER UP OUTSIDE


  function onScrollPointerUpOutside(e) {
    var obj = this.masked;
    obj.isScrolling = false;
    newMouseTime = new Date().getTime();
    newMousePos = e.data.getLocalPosition(this.parent);

    if (oldMousePos != undefined) {
      var duration = 0.75;
      var scrollSpeed = (newMousePos.y - oldMousePos.y) * scrollSensitivity_num * 3 / (newMouseTime - oldMouseTime);
      var textTargetY = obj.y + scrollSpeed * duration / 0.016;
      textTargetY = Math.min(Math.max(textTargetY, obj.maxY), obj.minY);
      var moveFactor = (textTargetY - obj.minY) / (obj.maxY - obj.minY);
      var scrollTargetY = obj.scrollBar.minY + (obj.scrollBar.maxY - obj.scrollBar.minY) * moveFactor;
      keepMoving(obj, duration, textTargetY, scrollTargetY);
      fixScroll(obj);
    }
  } // ON SCROLL


  function onScrollPointerMove(e) {
    var obj = this.masked;

    if (obj.isScrolling) {
      oldMousePos = newMousePos;
      newMousePos = e.data.getLocalPosition(this.parent);
      oldMouseTime = newMouseTime;
      newMouseTime = new Date().getTime();

      if (newMouseTime - startMouseTime > minDragTime && Math.abs(oldMousePos.y - startMousePos.y) > minDragSpace) {
        wasDragging_bool = true;
      }

      var sensitivity = scrollSensitivity_num;

      if (obj.y < obj.maxY && newMousePos.y - oldMousePos.y < 0 || obj.y > obj.minY && newMousePos.y - oldMousePos.y > 0) {
        sensitivity /= 10;
      }

      obj.y += (newMousePos.y - oldMousePos.y) * sensitivity;
      var moveFactor = (obj.y - obj.minY) / (obj.maxY - obj.minY);
      obj.scrollBar.y = obj.scrollBar.minY + (obj.scrollBar.maxY - obj.scrollBar.minY) * moveFactor;
    }

    var gl_pos = e.data.getLocalPosition(APP.stage);
    var child = PIXI.interaction.InteractionManager.prototype.hitTest(gl_pos, obj);
    var chLen = obj.children.length;

    for (var i = 0; i < chLen; i++) {
      if (obj.children[i].onMouseOut && child != obj.children[i]) {
        obj.children[i].onMouseOut(e);
      }
    }

    if (child != undefined) {
      if (child.onMouseOver && !obj.isScrolling) {
        child.onMouseOver(e);
      } //            if ((child.onPointerDown) && (obj.isScrolling)) {
      //                //child.onPointerDown(e);
      //            }

    }
  } // ON SCROLL WHEEL


  function onScrollMouseWheel(e) {
    if (currentScrollable_object != undefined) {
      obj = currentScrollable_object;
      var duration = 0.2;
      var scrollSpeed = e.wheelDelta * scrollSensitivity_num * 0.03;
      var textTargetY = obj.y + scrollSpeed * duration / 0.016;
      textTargetY = Math.min(Math.max(textTargetY, obj.maxY), obj.minY);
      var moveFactor = (textTargetY - obj.minY) / (obj.maxY - obj.minY);
      var scrollTargetY = obj.scrollBar.minY + (obj.scrollBar.maxY - obj.scrollBar.minY) * moveFactor;

      if (obj.textAnim != undefined) {
        obj.textAnim.kill();
        obj.scrollAnim.kill();
      }

      keepMoving(obj, duration, textTargetY, scrollTargetY);
    }
  } // SET SCROLL OBJECT


  function onScrollPointerOver(e) {
    this.pointerIsOver = true;
    currentScrollable_object = this.masked;
  } // REMOVE SCROLL OBJECT


  function onScrollPointerOut(e) {
    this.pointerIsOver = false;
    currentScrollable_object = undefined;
  } // INERTION


  function keepMoving(obj, duration, textTargetY, scrollTargetY) {
    obj.textAnim = TweenMax.to(obj, duration, {
      pixi: {
        y: textTargetY
      },
      ease: Power2.easeOut
    });
    obj.scrollAnim = TweenMax.to(obj.scrollBar, duration, {
      pixi: {
        y: scrollTargetY
      },
      ease: Power2.easeOut
    });
  } // DRAG BOUNCE


  function fixScroll(obj) {
    if (obj.y > obj.minY) {
      obj.textAnim = TweenMax.to(obj, 0.4, {
        pixi: {
          y: obj.minY
        },
        ease: Elastic.easeOut.config(1, 0.3)
      });
      obj.scrollAnim = TweenMax.to(obj.scrollBar, 0.4, {
        pixi: {
          y: obj.scrollBar.minY
        },
        ease: Elastic.easeOut.config(1, 0.3)
      });
      return;
    }

    if (obj.y < obj.maxY) {
      obj.textAnim = TweenMax.to(obj, 0.4, {
        pixi: {
          y: obj.maxY
        },
        ease: Elastic.easeOut.config(1, 0.3)
      });
      obj.scrollAnim = TweenMax.to(obj.scrollBar, 0.4, {
        pixi: {
          y: obj.scrollBar.maxY
        },
        ease: Elastic.easeOut.config(1, 0.3)
      });
      return;
    }
  }

  var allSounds = [];
  var soundOn = true;

  if (loadObject("soundOn") != null) {
    soundOn = loadObject("soundOn");
  }

  function enableSound() {
    soundOn = true;
    saveObject("soundOn", true);
  }

  function disableSound() {
    soundOn = false;
    saveObject("soundOn", false);
  }

  function toggleSound() {
    if (soundOn) {
      disableSound();
    } else {
      enableSound();
    }
  }

  function playSound(soundName) {
    if (!soundOn) return null; //returns soundID

    return allSounds[soundName].play();
  }

  function stopSound(soundName, id) {
    if (!soundOn) return null;
    if (id) allSounds[soundName].stop(id);else allSounds[soundName].stop();
  }

  function setVolume(soundName, volume) {
    if (!soundOn) return null;
    allSounds[soundName].volume(volume);
  }

  function setRate(soundName, rate) {
    if (!soundOn) return null;
    allSounds[soundName].rate(rate);
  }

  function fadeSound(soundName, from, to, duration, id) {
    if (!soundOn) return null;
    if (id) allSounds[soundName].fade(from, to, duration, id);else allSounds[soundName].fade(from, to, duration);
  } //initialize


  var analyticsInitialized = false;

  try {
    GameAnalytics("initialize", "bbaf9db13f1889a43438b2e4515ade01", "17d6c2865ac27cd6cfbeee2cf577f06258c3175e");
    analyticsInitialized = true;
  } catch (e) {
    analyticsInitialized = false;
  } //level started


  function analyticsLevelStarted(levelNum) {
    if (!analyticsInitialized) return;
    GameAnalytics("addProgressionEvent", "Start", "level " + levelNum);
  } //level failed


  function analyticsLevelFailed(levelNum) {
    if (!analyticsInitialized) return;
    GameAnalytics("addProgressionEvent", "Fail", "level " + levelNum);
  } //level completed


  function analyticsLevelCompleted(levelNum) {
    if (!analyticsInitialized) return;
    GameAnalytics("addProgressionEvent", "Complete", "level " + levelNum);
  } //error event - severity (Debug, Info, Warning, Error, Critical)


  function analyticsErrorEvent(errorMsg, severity) {
    if (!analyticsInitialized) return;
    severity = severity || "Debug";
    GameAnalytics("addErrorEvent", severity, errorMsg);
  }

  function analyticsCustiomEvent(eventName, value) {
    if (!analyticsInitialized) return;

    if (value != undefined) {
      GameAnalytics("addDesignEvent", eventName, value);
    } else {
      GameAnalytics("addDesignEvent", eventName);
    }
  }

  var transition = {};
  transition.defaultDuration = 0.75;
  transition.tweens = [];
  transition.isRunning = false;
  transition.resizeCall = null;

  transition.setScreen = function (screen) {
    if (transition.activeScreen) {
      transition.previousScreen = transition.activeScreenScreen;
      transition.activeScreen.root.visible = false;
    }

    screen.root.parent.toFront(screen.root);
    transition.activeScreen = screen;
    transition.activeScreen.root.visible = true;
    transition.resizeCall = null;
    transition.isRunning = false;
    screen.resize();
  };

  transition.fade = function (screen, duration, callback) {
    if (transition.isRunning) {
      setTimeout(transition.fade, 100, screen, duration);
      return;
    }

    transition.isRunning = true;

    if (duration == undefined) {
      duration = transition.defaultDuration;
    }

    screen.resize();
    transition.previousScreen = transition.activeScreen;
    transition.activeScreen = screen;
    transition.activeScreen.root.visible = true;
    transition.activeScreen.root.alpha = 0;
    transition.resizeCall = null;
    transition.activeScreen.resize(); //out

    transition.tweens[0] = TweenMax.to(transition.previousScreen.root, duration, {
      pixi: {
        alpha: 0
      },
      onComplete: function onComplete() {
        transition.previousScreen.root.visible = false;
        transition.activeScreen.root.parent.toFront(transition.activeScreen.root);
        transition.isRunning = false;

        if (callback) {
          callback();
        }
      }
    }); //in

    transition.tweens[1] = TweenMax.to(transition.activeScreen.root, duration, {
      pixi: {
        alpha: 1
      }
    });
  };

  transition.fadeToColor = function (screen, duration, color, callback) {
    if (transition.isRunning) {
      setTimeout(transition.fadeToColor, 100, screen, duration, color);
      return;
    }

    transition.isRunning = true;

    if (color == undefined) {
      color = 0x000000;
    }

    if (duration == undefined) {
      duration = transition.defaultDuration;
    }

    transition.previousScreen = transition.activeScreen;
    transition.activeScreen = screen;
    var color_sprite = new WhiteRectangle(APP.stage, [APP.screen.width, APP.screen.height], color);
    color_sprite.alpha = 0;
    color_sprite.anchor.set(0);

    transition.resizeCall = function () {
      color_sprite.width = APP.screen.width;
      color_sprite.height = APP.screen.height;
    }; //color in


    transition.tweens[0] = TweenMax.to(color_sprite, duration * 0.45, {
      pixi: {
        alpha: 1
      },
      onComplete: function onComplete() {
        transition.previousScreen.root.visible = false;
        transition.activeScreen.root.visible = true;
        transition.activeScreen.resize();
        transition.activeScreen.root.parent.toFront(transition.activeScreen.root);
      }
    }); //color out

    transition.tweens[1] = TweenMax.to(color_sprite, duration * 0.45, {
      pixi: {
        alpha: 0
      },
      delay: duration * 0.55,
      onComplete: function onComplete() {
        transition.isRunning = false;
        transition.resizeCall = null;
        color_sprite["delete"]();

        if (callback) {
          callback();
        }
      }
    });
  };

  transition.slide = function (screen, duration, xDirection, yDirection, callback) {
    if (transition.isRunning) {
      setTimeout(transition.slide, 100, screen, xDirection, yDirection);
      return;
    }

    transition.isRunning = true;

    if (xDirection == undefined && yDirection == undefined) {
      xDirection = 0;
      yDirection = 1;
    }

    if (duration == undefined) {
      duration = transition.defaultDuration;
    }

    transition.previousScreen = transition.activeScreen;
    transition.previousScreen.root.x = 0;
    transition.previousScreen.root.y = 0;
    transition.activeScreen = screen;
    transition.activeScreen.root.visible = true;
    transition.activeScreen.root.x = APP.screen.width * xDirection;
    transition.activeScreen.root.y = APP.screen.height * yDirection;
    transition.activeScreen.resize();

    transition.resizeCall = function () {
      for (var i = 0; i < transition.tweens.length; i++) {
        if (transition.tweens[i]) {
          transition.tweens[i].kill();
        }
      }

      transition.previousScreen.root.setTransform(0, 0);
      transition.activeScreen.root.setTransform(0, 0);
      transition.previousScreen.root.visible = false;
      transition.activeScreen.root.visible = true;
      transition.activeScreen.root.parent.toFront(transition.activeScreen.root);
      transition.isRunning = false;
      transition.resizeCall = null;
    }; //previous out


    transition.tweens[0] = TweenMax.to(transition.previousScreen.root, duration, {
      pixi: {
        x: -APP.screen.width * xDirection,
        y: -APP.screen.height * yDirection
      },
      ease: Power3.easeInOut,
      onComplete: function onComplete() {
        transition.previousScreen.root.setTransform(0, 0);
        transition.activeScreen.root.setTransform(0, 0);
        transition.previousScreen.root.visible = false;
        transition.activeScreen.root.visible = true;
        transition.activeScreen.root.parent.toFront(transition.activeScreen.root);
        transition.isRunning = false;
        transition.resizeCall = null;

        if (callback) {
          callback();
        }
      }
    }); //active in

    transition.tweens[1] = TweenMax.to(transition.activeScreen.root, duration, {
      pixi: {
        x: 0,
        y: 0
      },
      ease: Power3.easeInOut,
      delay: 0
    });
  };

  transition.resize = function () {
    if (transition.resizeCall) {
      transition.resizeCall();
    }
  };

  resize_methods.push(transition.resize);
  var tutorial = {};

  tutorial.setup = function () {
    tutorial.pointerupImg = "tut-pointerup.png";
    tutorial.pointerdownImg = "tut-pointerdown.png";
    tutorial.thumbsupImg = "tut-thumbsup.png";
    tutorial.numOfSteps = 3;
    tutorial.currentStep = 0;
    tutorial.onComplete = gameScreen.updatePowerUps;
    tutorial.drags = [{
      start: gameScreen.getNumberPos(1, 1),
      end: gameScreen.getNumberPos(1, 2),
      img: "gem1.png"
    }, {
      start: gameScreen.getNumberPos(2, 2),
      end: gameScreen.getNumberPos(1, 2),
      img: "gem2.png"
    }, {
      start: gameScreen.getNumberPos(1, 2),
      end: gameScreen.getNumberPos(0, 2),
      img: "gem3.png"
    }];
  };

  tutorial.draw = function (parent) {
    tutorial.setup();
    tutorial.handContainer = new Container(parent);
    tutorial.handContainer.alpha = 0;
    tutorial.handContainer.position = tutorial.drags[0].start;
    tutorial.objSprite = new Sprite(tutorial.handContainer, tutorial.drags[0].img);
    tutorial.objSprite.alpha = 0;
    tutorial.handSprite = new Sprite(tutorial.handContainer, tutorial.pointerupImg);
    tutorial.handSprite.position.set(20, 90);
    tutorial.handSprite.scale.set(0.75);
    tutorial.isDrawn = true;
    tutorial.resize();
  };

  tutorial.playStep = function () {
    TweenMax.killTweensOf(tutorial.handContainer);
    TweenMax.killTweensOf(tutorial.handSprite);
    clearInterval(tutorial.interval);

    if (tutorial.currentStep < tutorial.numOfSteps) {
      var duration = 0.5;
      var delay = 0.5;

      if (tutorial.currentStep == 0) {
        duration = 0.1;
        delay = 0.2;
      }

      tutorial.handSprite.texture = PIXI.utils.TextureCache[tutorial.pointerupImg];
      tutorial.objSprite.alpha = 0;
      TweenMax.to(tutorial.handContainer, duration, {
        pixi: {
          x: tutorial.drags[tutorial.currentStep].start.x,
          y: tutorial.drags[tutorial.currentStep].start.y,
          scale: 1,
          alpha: 1
        },
        ease: Power2.easeInOut,
        delay: delay,
        onComplete: function onComplete() {
          var drag = function drag() {
            tutorial.handSprite.texture = PIXI.utils.TextureCache[tutorial.pointerdownImg];
            tutorial.objSprite.texture = PIXI.utils.TextureCache[tutorial.drags[tutorial.currentStep].img];
            tutorial.objSprite.alpha = 0.33;
            TweenMax.to(tutorial.handContainer, 0.2, {
              pixi: {
                scale: 0.9
              },
              ease: Power2.easeOut
            });
            TweenMax.to(tutorial.handContainer, 1.5, {
              pixi: {
                x: tutorial.drags[tutorial.currentStep].end.x,
                y: tutorial.drags[tutorial.currentStep].end.y
              },
              ease: Power2.easeInOut,
              onComplete: function onComplete() {
                tutorial.handSprite.texture = PIXI.utils.TextureCache[tutorial.pointerupImg];
                tutorial.objSprite.alpha = 0;
              }
            });
            TweenMax.to(tutorial.handContainer, 0.5, {
              pixi: {
                x: tutorial.drags[tutorial.currentStep].start.x,
                y: tutorial.drags[tutorial.currentStep].start.y
              },
              ease: Power2.easeInOut,
              delay: 2
            });
            TweenMax.to(tutorial.handContainer, 0.2, {
              pixi: {
                scale: 1
              },
              ease: Power2.easeOut,
              delay: 2
            });
          };

          drag();
          tutorial.interval = setInterval(drag, 3100);
        }
      });
    } //thumbs up
    else {
        var mainDelay = 2;
        tutorial.objSprite.alpha = 0;
        TweenMax.to(tutorial.handContainer, 0.2, {
          pixi: {
            alpha: 0
          }
        });
        TweenMax.to(tutorial.handContainer, 0.2, {
          pixi: {
            alpha: 1
          },
          delay: mainDelay
        });
        TweenMax.to(tutorial.handContainer, 0.7, {
          pixi: {
            x: 0,
            y: 0,
            scale: 1.5
          },
          delay: mainDelay,
          ease: Power2.easeInOut
        });
        TweenMax.to(tutorial.handContainer, 0.3, {
          pixi: {
            scale: 0.75,
            alpha: 0
          },
          delay: mainDelay + 1.5,
          ease: Back.easeIn.config(1.7),
          onComplete: function onComplete() {
            tutorial.isDrawn = false;
            tutorial.handContainer["delete"]();
            saveObject("seenTutorial", true);

            if (tutorial.onComplete) {
              tutorial.onComplete();
            }
          }
        });
        TweenMax.to(tutorial.handSprite, 0.25, {
          pixi: {
            x: 0,
            y: 0,
            rotation: 45
          },
          delay: mainDelay,
          ease: Power2.easeIn,
          onComplete: function onComplete() {
            tutorial.handSprite.texture = PIXI.utils.TextureCache[tutorial.thumbsupImg];
          }
        });
        TweenMax.to(tutorial.handSprite, 0.25, {
          pixi: {
            rotation: 90
          },
          ease: Power2.easeOut,
          delay: mainDelay + 0.25
        });
      }
  };

  tutorial.nextStep = function () {
    tutorial.currentStep++;
    tutorial.playStep();
  };

  tutorial.resize = function () {
    if (tutorial.isDrawn) {
      tutorial.handContainer.rotation = -tutorial.handContainer.parent.rotation;
    }
  };

  resize_methods.push(tutorial.resize); //SCREENS

  var gameScreen = {}; //draw

  gameScreen.draw = function (resources) {
    var s = gameScreen;
    s.root = new Container(screen_container);
    screen_container.toBack(s.root); //    s.guide = new WhiteRectangle(s.root, [3000, 33], primaryPalette[1]);
    //    s.guide.anchor.set(0);
    //    s.guide.alpha=0.2;

    var scoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 40,
      fill: [primaryPalette[1]],
      align: "right"
    });
    var scoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 40,
      fill: [primaryPalette[1]],
      align: "right"
    });
    var noValidTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 32,
      fill: [0xf8273a],
      align: "center"
    });
    var bestScoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 25,
      fill: [primaryPalette[1]],
      align: "right"
    });
    var nextTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 32,
      fill: [primaryPalette[1]],
      align: "left"
    });
    s.background = new WhiteRectangle(s.root, [5, 5], 0xdae3e9);
    s.background.alpha = 1;
    s.background.anchor.set(0);
    s.background.interactive = true;

    s.background.onPointerUp = function (e) {
      gameLogic.unselectAll();
    };

    s.background.on("pointerup", s.background.onPointerUp);
    s.backgroundBlack = new WhiteRectangle(s.root, [5, 5], 0x000000);
    s.backgroundBlack.alpha = 0;
    s.backgroundBlack.anchor.set(0);
    s.dust = new Dust(s.root, 2, 200, [0xffffff, 0xffffdd, 0xffddff, 0xddffff], 1);
    s.dust.alpha = 0;
    s.bgGlow = new Sprite(s.root, imgRoot + "glow.svg");
    s.bgGlow.alpha = 0;
    s.bgGlowBlack = new Sprite(s.root, imgRoot + "glow.svg");
    s.bgGlowBlack.alpha = 0;
    s.bgGlowBlack.tint = 0x000000;
    s.numContParent = new Container(s.root);
    s.numbersContainer = new Container(s.numContParent);
    s.dotsContainer = new Container(s.numbersContainer);
    s.nextNumContainer = new Container(s.root);
    s.nextNumMainContainer = new Container(s.nextNumContainer);
    s.nextNumMainContainer.scale.set(0.8);
    s.nextText = new Text(s.nextNumMainContainer, getText("next"), nextTextStyle);
    s.nextText.y = -80;
    s.nextSprite = new Sprite(s.nextNumMainContainer, "next1.png");
    s.whiteCircle = new Circle(s.nextNumMainContainer, s.nextSprite.width * 0.55);
    s.maskCircle = new Circle(s.nextNumMainContainer, s.nextSprite.width * 0.5, [0, 0, 0], [0xffffff, 1], false);
    s.nextSprite.mask = s.maskCircle;
    var angles = [];
    var colors = [];

    for (var i = 0; i < gameLogic.drawDeck.length + 2; i++) {
      angles.push(i * 360 / (gameLogic.drawDeck.length + 1) - 90);
      colors.push(primaryPalette[1]);
    }

    s.progressPie = new Pie(s.nextNumMainContainer, s.nextSprite.width * 0.6, angles, [0.1, 0, 1], colors, true);
    gameScreen.resetProgress();
    s.nextNumMainContainer.toBack(s.progressPie);
    s.nextNumMainContainer.toFront(s.nextSprite);
    s.scoreContainer = new Container(s.root);
    s.scoreText = new Text(s.scoreContainer, "", scoreTextStyle);
    s.scoreText.anchor.set(1, 0);
    s.trophySprite = new Sprite(s.scoreContainer, "trophy.png");
    s.trophySprite.anchor.set(1, 0);
    s.trophySprite.y = s.scoreText.height - 1;
    s.trophySprite.x = -2;
    s.trophySprite.alpha = 0.5;
    s.bestScoreText = new Text(s.scoreContainer, "0", bestScoreTextStyle);
    s.bestScoreText.alpha = 0.5;
    s.bestScoreText.anchor.set(1, 0);
    s.bestScoreText.y = s.scoreText.height - 6;
    s.bestScoreText.x = -s.trophySprite.width - 4;
    s.menuBtnContainer = new Container(s.root);
    s.menuBtn = new SpriteButton(s.menuBtnContainer, s.openMenu, "menuBtn.png", true, [2, 2], ["Escape"]);
    s.menuBtn.setTransform(s.menuBtn.width / 4, s.menuBtn.height / 4);
    var timerStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 32,
      fill: [0x000000],
      align: "center",
      lineJoin: "round",
      miterLimit: 0,
      stroke: "white",
      strokeThickness: 10
    });
    s.powerUpContainer = new Container(s.root);
    s.powerUpBtns = [];
    s.powerUpBtns[0] = new Button(s.powerUpContainer, "powerUpTitle0", "PU_0.png", null, PU_BUTTON, ["Digit1", "Numpad1"]);
    s.powerUpBtns[0].adSprite = new Sprite(s.powerUpBtns[0], "adIcon.png");
    s.powerUpBtns[0].adSprite.setTransform(40, 40, 0.75, 0.75);
    s.powerUpBtns[0].timer = new Text(s.powerUpBtns[0], "", timerStyle);
    s.powerUpBtns[0].x = -375;
    s.powerUpBtns[0].stX = s.powerUpBtns[0].x;

    s.powerUpBtns[0].callback = function () {
      if (gameLogic.lock) return;

      if (gameLogic.activePowerUps[0]) {
        s.openPowerUpInfo(gameLogic.PU_1to2);
      }
    };

    s.powerUpBtns[1] = new Button(s.powerUpContainer, "powerUpTitle1", "PU_1.png", null, PU_BUTTON, ["Digit2", "Numpad2"]);
    s.powerUpBtns[1].adSprite = new Sprite(s.powerUpBtns[1], "adIcon.png");
    s.powerUpBtns[1].adSprite.setTransform(40, 40, 0.75, 0.75);
    s.powerUpBtns[1].timer = new Text(s.powerUpBtns[1], "", timerStyle);
    s.powerUpBtns[1].x = 0;
    s.powerUpBtns[1].stX = s.powerUpBtns[1].x;

    s.powerUpBtns[1].callback = function () {
      if (gameLogic.lock) return;

      if (gameLogic.activePowerUps[1]) {
        s.openPowerUpInfo(gameLogic.PU_WILD);
      }
    };

    s.powerUpBtns[2] = new Button(s.powerUpContainer, "powerUpTitle2", "PU_2.png", null, PU_BUTTON, ["Digit3", "Numpad3"]);
    s.powerUpBtns[2].adSprite = new Sprite(s.powerUpBtns[2], "adIcon.png");
    s.powerUpBtns[2].adSprite.setTransform(40, 40, 0.75, 0.75);
    s.powerUpBtns[2].timer = new Text(s.powerUpBtns[2], "", timerStyle);
    s.powerUpBtns[2].x = 375;
    s.powerUpBtns[2].stX = s.powerUpBtns[2].x;

    s.powerUpBtns[2].callback = function () {
      if (gameLogic.lock) return;

      if (!gameLogic.shifting) {
        s.openPowerUpInfo(gameLogic.PU_SHIFT);
      }
    }; //setInterval(s.updatePowerUpsTimer, 1000);


    s.shiftDoneBtn = new SpriteButton(s.powerUpContainer, null, "check.png", true, [1.5, 1.5], ["Escape", "Space", "Enter"]);
    s.shiftDoneBtn.x = 0;
    s.noValidMovesText = new Text(s.powerUpContainer, "", noValidTextStyle);
    s.noValidMovesText.visible = false;
    s.shiftDoneBtn.y = 200;
    s.shiftDoneBtn.scale.set(0.4);
    s.shiftDoneBtn.stY = s.shiftDoneBtn.y;

    s.shiftDoneBtn.callback = function () {
      if (gameLogic.shifting) {
        playSound("btnClick");
        gameLogic.stopShifting();
        gameLogic.activePowerUps[2] = false;
        gameScreen.updatePowerUps();
        gameLogic.saveState(true);
      }
    };

    s.selectionCircle = new Circle(s.numbersContainer, 120, [5, 0xffffff, 1], [0x000000, 0.1]);
    s.selectionCircle.hidden = true;
    s.selectionCircle.alpha = 0;
    s.selectionCircle.i = 1;
    s.selectionCircle.j = 1;
    s.selectionCircle.position = s.getNumberPos(1, 1);
    s.numbersContainer.toBack(s.selectionCircle);
    s.isDrawn = true;
    s.resize();
    s.root.visible = false; //localStorage.clear();

    if (!gameLogic.loadState()) {
      if (loadObject("seenTutorial")) {
        gameScreen.drawLevel(levels[0], true);
        gameLogic.resetGame(true);
      } else {
        gameScreen.drawLevel(levels[0], false);
        gameLogic.resetGame(false);
        tutorial.draw(s.numbersContainer);
        gameScreen.updatePowerUps();
      }
    }
  };

  gameScreen.drawLevel = function (state, shuffle) {
    var s = gameScreen;
    gameLogic.m = state.matrix.length;
    gameLogic.n = state.matrix[0].length;
    s.nextNumContainer.defScale = 1;
    s.shiftColBtns = [];
    s.shiftRowBtns = [];
    if (shuffle == undefined) shuffle = true;
    var v, t, c, l;
    if (shuffle) shuffleArray(state.matrix);

    for (var i = 0; i < gameLogic.m; i++) {
      if (shuffle) shuffleArray(state.matrix[i]);
      gameLogic.numbers[i] = [];

      for (var j = 0; j < gameLogic.n; j++) {
        v = state.matrix[i][j].v;
        l = state.matrix[i][j].l;
        gameLogic.numbers[i][j] = new NumberShape(s.numbersContainer, v, l);
        gameLogic.numbers[i][j].position = s.getNumberPos(i, j);
        gameLogic.numbers[i][j].i = i;
        gameLogic.numbers[i][j].j = j;
      }
    }

    for (var k = 0; k < gameLogic.n * 2; k++) {
      var j = k % gameLogic.n;
      s.shiftColBtns[k] = new Button(s.numbersContainer, "", ["play.png"], null, SHIFT_BUTTON);
      s.shiftColBtns[k].column = j;

      s.shiftColBtns[k].callback = function () {
        gameLogic.shiftColumn(this.column, this.dir);
      };

      s.shiftColBtns[k].stX = gameLogic.numbers[0][j].x;

      if (k < gameLogic.n) {
        s.shiftColBtns[k].dir = -1;
        s.shiftColBtns[k].stY = gameLogic.numbers[0][j].y - 225;
      } else {
        s.shiftColBtns[k].dir = 1;
        s.shiftColBtns[k].stY = gameLogic.numbers[gameLogic.m - 1][j].y + 225;
      }

      s.shiftColBtns[k].setTransform(s.shiftColBtns[k].stX, s.shiftColBtns[k].stY);
      s.shiftColBtns[k].rotation = s.shiftColBtns[k].dir * Math.PI / 2;
      s.shiftColBtns[k].alpha = 0;
      s.shiftColBtns[k].disable();
    }

    for (var k = 0; k < gameLogic.m * 2; k++) {
      var i = k % gameLogic.m;
      s.shiftRowBtns[k] = new Button(s.numbersContainer, "", ["play.png"], null, SHIFT_BUTTON);
      s.shiftRowBtns[k].row = i;

      s.shiftRowBtns[k].callback = function () {
        gameLogic.shiftRow(this.row, this.dir);
      };

      s.shiftRowBtns[k].stY = gameLogic.numbers[i][0].y;

      if (k < gameLogic.m) {
        s.shiftRowBtns[k].dir = -1;
        s.shiftRowBtns[k].stX = gameLogic.numbers[i][0].x - 225;
      } else {
        s.shiftRowBtns[k].dir = 1;
        s.shiftRowBtns[k].stX = gameLogic.numbers[i][gameLogic.n - 1].x + 225;
      }

      s.shiftRowBtns[k].setTransform(s.shiftRowBtns[k].stX, s.shiftRowBtns[k].stY);
      s.shiftRowBtns[k].rotation = (s.shiftRowBtns[k].dir - 1) * Math.PI / 2;
      s.shiftRowBtns[k].alpha = 0;
      s.shiftRowBtns[k].disable();
    }

    s.drawDots();
    s.numbersContainer.alpha = 0;
    TweenMax.to(s.numbersContainer, 0.5, {
      pixi: {
        alpha: 1
      },
      delay: 0.2
    });
    s.resize();
  };

  gameScreen.drawDots = function () {
    var s = gameScreen;
    var numOfDots = 12;

    for (var i = 0; i < gameLogic.m; i++) {
      for (var j = 0; j < gameLogic.n; j++) {
        if (gameLogic.numbers[i][j] == undefined) continue;
        var xDots = [];
        var yDots = [];

        for (var k = 0; k < numOfDots; k++) {
          //xDots
          if (j < gameLogic.n - 1) {
            if (gameLogic.numbers[i][j + 1]) {
              xDots[k] = new Circle(s.dotsContainer, 6);
              xDots[k].tint = primaryPalette[1];
              xDots[k].alpha = 0.1;
              xDots[k].scale.set(0.5);
              xDots[k].x = gameLogic.numbers[i][j].x + (gameLogic.numbers[i][j + 1].x - gameLogic.numbers[i][j].x) * (k + 0.5) / numOfDots;
              xDots[k].y = gameLogic.numbers[i][j].y + (gameLogic.numbers[i][j + 1].y - gameLogic.numbers[i][j].y) * (k + 0.5) / numOfDots;
              gameLogic.numbers[i][j].rightDots = xDots;
              gameLogic.numbers[i][j + 1].leftDots = xDots;
            }
          } //yDots


          if (i < gameLogic.m - 1) {
            if (gameLogic.numbers[i + 1][j]) {
              yDots[k] = new Circle(s.dotsContainer, 6);
              yDots[k].tint = primaryPalette[1];
              yDots[k].alpha = 0.1;
              yDots[k].scale.set(0.5);
              yDots[k].x = gameLogic.numbers[i][j].x + (gameLogic.numbers[i + 1][j].x - gameLogic.numbers[i][j].x) * (k + 0.5) / numOfDots;
              yDots[k].y = gameLogic.numbers[i][j].y + (gameLogic.numbers[i + 1][j].y - gameLogic.numbers[i][j].y) * (k + 0.5) / numOfDots;
              gameLogic.numbers[i][j].downDots = yDots;
              gameLogic.numbers[i + 1][j].upDots = yDots;
            }
          }
        }
      }
    }
  };

  gameScreen.updateNextValue = function (nextValue) {
    TweenMax.to(gameScreen.nextSprite, 0.3, {
      pixi: {
        y: 150
      },
      ease: Power2.easeIn,
      delay: 0.1,
      onComplete: function onComplete() {
        gameScreen.nextSprite.y = -150;

        if (nextValue != 0) {
          gameScreen.nextSprite.texture = PIXI.utils.TextureCache["next" + nextValue + ".png"];
        } else {
          gameScreen.nextSprite.texture = PIXI.utils.TextureCache["next0_0.png"];
        }

        TweenMax.to(gameScreen.nextSprite, 0.3, {
          pixi: {
            y: 0
          },
          ease: Power2.easeOut
        });
      }
    });
  };

  gameScreen.updateProgress = function (progress) {
    var len = gameScreen.progressPie.sectors.length;

    if (gameScreen.progressPie.resetTween) {
      gameScreen.progressPie.resetTween.kill();
      gameScreen.resetProgress();
      gameScreen.progressPie.resetTween = null;
    }

    for (var i = 0; i < len; i++) {
      if (i <= len * progress) {
        TweenMax.to(gameScreen.progressPie.sectors[i], 0.2, {
          pixi: {
            alpha: 1
          },
          ease: Power2.easeOut,
          delay: 0.4
        });
      } else {
        TweenMax.to(gameScreen.progressPie.sectors[i], 0.2, {
          pixi: {
            alpha: 0
          },
          ease: Power2.easeOut,
          delay: 0.4
        });
      }
    }

    if (progress == 1) {
      gameScreen.progressPie.resetTween = TweenMax.to(gameScreen.progressPie, 0.3, {
        pixi: {
          alpha: 0
        },
        ease: Power2.easeOut,
        yoyo: true,
        repeat: -1,
        delay: 0.4,
        onComplete: function onComplete() {
          gameScreen.resetProgress();
        }
      });
    }
  };

  gameScreen.resetProgress = function () {
    TweenMax.to(gameScreen.progressPie, 0.2, {
      pixi: {
        alpha: 1
      },
      ease: Power2.easeOut
    });

    for (var i = 0; i < gameScreen.progressPie.sectors.length; i++) {
      TweenMax.to(gameScreen.progressPie.sectors[i], 0.2, {
        pixi: {
          alpha: 0
        },
        ease: Power2.easeOut
      });
    }
  };

  gameScreen.enlargePowerUps = function () {
    var s = gameScreen;
    s.bgGlowBlack.alphaTween = TweenMax.to([s.bgGlowBlack], 2, {
      pixi: {
        alpha: 0.1
      },
      repeat: -1,
      yoyo: true
    });
    s.backgroundBlack.alphaTween = TweenMax.to(s.backgroundBlack, 2, {
      pixi: {
        alpha: 0.2
      },
      repeat: -1,
      yoyo: true
    });

    for (var i = 0; i < s.powerUpBtns.length; i++) {
      TweenMax.to(s.powerUpBtns[i], 0.3, {
        pixi: {
          scale: 1.2,
          x: s.powerUpBtns[i].stX * 1.25,
          y: -15
        },
        ease: Power2.easeOut,
        delay: 1 + i * 0.1
      });

      if (gameLogic.activePowerUps[i]) {
        s.powerUpBtns[i].shakeInterval = setInterval(function (ind) {
          shakeScreen(5, 250, gameScreen.powerUpBtns[ind].img);
        }, 3000 + i * 100, i);
      }
    }

    TweenMax.to(s.numbersContainer, 1, {
      pixi: {
        alpha: 1
      },
      delay: 1
    });
  };

  gameScreen.shrinkPowerUps = function (tweenButtons) {
    if (tutorial.isDrawn) return;
    if (tweenButtons == undefined) tweenButtons = true;
    var s = gameScreen;

    if (s.bgGlowBlack.alphaTween) {
      s.bgGlowBlack.alphaTween.kill();
      s.backgroundBlack.alphaTween.kill();
      s.bgGlowBlack.alphaTween = null;
      s.backgroundBlack.alphaTween = null;
      TweenMax.to([s.bgGlowBlack, s.backgroundBlack], 0.5, {
        pixi: {
          alpha: 0
        }
      });
    }

    for (var i = 0; i < s.powerUpBtns.length; i++) {
      clearInterval(s.powerUpBtns[i].shakeInterval);

      if (tweenButtons) {
        TweenMax.to(s.powerUpBtns[i], 0.3, {
          pixi: {
            scale: 1,
            x: s.powerUpBtns[i].stX,
            y: 0
          },
          ease: Power2.easeOut,
          delay: i * 0.1
        });
      }
    }

    TweenMax.to(s.numbersContainer, 0.5, {
      pixi: {
        alpha: 1
      }
    });
  };

  gameScreen.updatePowerUpsTimer = function () {
    var s = gameScreen;
    if (!s.powerUpBtns) return;
    var wait = ads.getWaitingTime();

    for (var i = 0; i < s.powerUpBtns.length; i++) {
      if (gameLogic.activePowerUps[i]) {
        if (wait > 0) {
          s.powerUpBtns[i].timer.text = milliToMMSS(wait);
          gameScreen.powerUpBtns[i].disable();
          gameScreen.powerUpBtns[i].adSprite.visible = false;
        } else {
          s.powerUpBtns[i].timer.text = "";
          gameScreen.powerUpBtns[i].enable();
          gameScreen.powerUpBtns[i].adSprite.visible = true;
        }
      } else {
        s.powerUpBtns[i].timer.text = "X";
        gameScreen.powerUpBtns[i].disable();
        gameScreen.powerUpBtns[i].adSprite.visible = false;
      }
    }
  };

  gameScreen.updatePowerUps = function () {
    setTimeout(function () {
      var s = gameScreen;

      if (tutorial.isDrawn || gameLogic.gameOver) {
        for (var i = 0; i < s.powerUpBtns.length; i++) {
          TweenMax.to(s.powerUpBtns[i], 0.25, {
            pixi: {
              y: s.shiftDoneBtn.stY
            },
            ease: Power2.easeIn
          });
        }

        return;
      }

      for (var i = 0; i < s.powerUpBtns.length; i++) {
        if (gameLogic.activePowerUps[i]) {
          gameScreen.powerUpBtns[i].enable();
          gameScreen.powerUpBtns[i].adSprite.visible = false;
        } else {
          gameScreen.powerUpBtns[i].disable();
          gameScreen.powerUpBtns[i].adSprite.visible = false;
          clearInterval(s.powerUpBtns[i].shakeInterval);
        }
      }

      if (gameLogic.shifting) {
        for (var i = 0; i < s.powerUpBtns.length; i++) {
          TweenMax.to(s.powerUpBtns[i], 0.25, {
            pixi: {
              y: s.shiftDoneBtn.stY
            },
            ease: Power2.easeIn
          });
        }

        TweenMax.to(s.shiftDoneBtn, 0.25, {
          pixi: {
            y: 0
          },
          ease: Power2.easeOut,
          delay: 0.5
        });
      } else {
        for (var i = 0; i < s.powerUpBtns.length; i++) {
          TweenMax.to(s.powerUpBtns[i], 0.25, {
            pixi: {
              y: 0,
              x: s.powerUpBtns[i].stX,
              scale: 1
            },
            ease: Power2.easeOut,
            delay: 0.5
          });
        }

        TweenMax.to(s.shiftDoneBtn, 0.25, {
          pixi: {
            y: s.shiftDoneBtn.stY
          },
          ease: Power2.easeIn
        });
      }
    }, 50);
  };

  gameScreen.disableShiftDone = function () {
    var s = gameScreen;
    s.shiftDoneBtn.visible = false;
    s.noValidMovesText.visible = true;
    s.noValidMovesText.alpha = 1;
    s.noValidMovesText.text = "x";
    s.noValidMovesText.alphaTween = TweenMax.to(s.noValidMovesText, 0.66, {
      pixi: {
        alpha: 1
      },
      repeat: -1,
      yoyo: true
    });
  };

  gameScreen.enableShiftDone = function () {
    var s = gameScreen;
    s.shiftDoneBtn.visible = true;
    s.noValidMovesText.visible = false;

    if (s.noValidMovesText.alphaTween) {
      s.noValidMovesText.alphaTween.kill();
      s.noValidMovesText.alphaTween = null;
    }
  };

  gameScreen.getNumberPos = function (i, j) {
    var pos = {};
    var space = 300;
    pos.x = -(space * (gameLogic.n - 1)) / 2 + j * space;
    pos.y = -(space * (gameLogic.m - 1)) / 2 + i * space;
    return pos;
  };

  gameScreen.updateDots = function (a, b, connect, remove) {
    var dots;
    var scale = 0.75;
    var alpha = 0.5;

    if (!connect && !remove) {
      scale = 0.5;
      alpha = 0.1;
    }

    if (remove) {
      scale = 0;
      alpha = 0;
    }

    var id = a.i - b.i;
    var jd = a.j - b.j;
    var dir = id + jd;

    if (id == 0 && jd == -1) {
      dots = a.rightDots;

      if (remove) {
        a.rightDots = null;
        b.leftDots = null;
      }
    }

    if (id == 0 && jd == 1) {
      dots = a.leftDots;

      if (remove) {
        b.rightDots = null;
        a.leftDots = null;
      }
    }

    if (id == -1 && jd == 0) {
      dots = a.downDots;

      if (remove) {
        a.downDots = null;
        b.upDots = null;
      }
    }

    if (id == 1 && jd == 0) {
      dots = a.upDots;

      if (remove) {
        b.downDots = null;
        a.upDots = null;
      }
    }

    if (dots == undefined) {
      return;
    }

    var len = dots.length;
    var delay;

    for (var i = 0; i < len; i++) {
      if (!dots[i]) return;
      delay = distance(dots[i], a) * 0.0002;
      dots[i].tween = TweenMax.to(dots[i], 0.12, {
        pixi: {
          scale: scale,
          alpha: alpha
        },
        delay: delay,
        ease: Power2.easeIn,
        onComplete: function onComplete(d, r) {
          if (r) {
            d["delete"]();
          }
        },
        onCompleteParams: [dots[i], remove]
      });
    }
  };

  gameScreen.disconnectDots = function (nums) {
    for (var i = 1; i < nums.length; i++) {
      gameScreen.updateDots(nums[i], nums[i - 1], false, false);
    }
  };

  gameScreen.clearLevel = function (revive) {
    var s = gameScreen;
    var hiddenCircle = s.selectionCircle.hidden;
    gameLogic.numbers = [];
    TweenMax.to(s.numbersContainer, 0.5, {
      pixi: {
        alpha: 0
      },
      onComplete: function onComplete(revive) {
        var s = gameScreen;
        s.numContParent["delete"]();
        s.numContParent = new Container(s.root);
        s.numbersContainer = new Container(s.numContParent);
        s.dotsContainer = new Container(s.numbersContainer);
        s.selectionCircle = new Circle(s.numbersContainer, 120, [5, 0xffffff, 1], [0x000000, 0.1]);
        gameLogic.hideSelectionCircle(hiddenCircle);
        s.selectionCircle.i = 1;
        s.selectionCircle.j = 1;
        s.selectionCircle.position = s.getNumberPos(1, 1);
        s.numbersContainer.toBack(s.selectionCircle);
        s.resize();

        if (!revive) {
          gameLogic.resetLevel();
          s.drawLevel(levels[0]);
          gameLogic.resetGame();
        } else {
          gameLogic.revive();
        }
      },
      onCompleteParams: [revive]
    });
  };

  gameScreen.showShiftButtons = function () {
    var s = gameScreen;

    for (var j = 0; j < gameLogic.n * 2; j++) {
      s.shiftColBtns[j].enable();
      s.shiftColBtns[j].img.x = -5;
      TweenMax.to(s.shiftColBtns[j], 0.5, {
        pixi: {
          alpha: 1
        },
        delay: 0.5
      });
      s.shiftColBtns[j].moveTweeen = TweenMax.to(s.shiftColBtns[j].img, 0.66, {
        pixi: {
          x: 10
        },
        yoyo: true,
        repeat: -1,
        ease: Power2.easeIn
      });
    }

    for (var i = 0; i < gameLogic.m * 2; i++) {
      s.shiftRowBtns[i].enable();
      s.shiftRowBtns[i].img.x = -5;
      TweenMax.to(s.shiftRowBtns[i], 0.5, {
        pixi: {
          alpha: 1
        },
        delay: 0.5
      });
      s.shiftRowBtns[i].moveTweeen = TweenMax.to(s.shiftRowBtns[i].img, 0.66, {
        pixi: {
          x: 10
        },
        yoyo: true,
        repeat: -1,
        ease: Power2.easeIn
      });
    }

    for (var i = 0; i < gameLogic.m; i++) {
      for (var j = 0; j < gameLogic.n; j++) {
        TweenMax.to(gameLogic.numbers[i][j].gemSprite, 0.5, {
          pixi: {
            alpha: 0.5
          },
          delay: 0.5
        });
      }
    }

    TweenMax.to(s.numbersContainer, 0.25, {
      pixi: {
        scale: 0.8
      },
      ease: Power2.easeOut
    }); //    for (var i = 0; i < s.powerUpBtns.length; i++) {
    //        TweenMax.to(s.powerUpBtns[i], 0.25, {
    //            pixi: {
    //                y: s.shiftDoneBtn.stY
    //            },
    //            ease: Power2.easeIn
    //        });
    //    }
    //
    //    TweenMax.to(s.shiftDoneBtn, 0.25, {
    //        pixi: {
    //            y: 0
    //        },
    //        ease: Power2.easeOut,
    //        delay: 0.5
    //    });
  };

  gameScreen.hideShiftButtons = function () {
    var s = gameScreen;

    for (var j = 0; j < gameLogic.n * 2; j++) {
      s.shiftColBtns[j].disable();
      TweenMax.to(s.shiftColBtns[j], 0.5, {
        pixi: {
          alpha: 0
        },
        //delay: (j % gameLogic.n) * 0.1,
        onComplete: function onComplete(btn) {
          if (btn.moveTweeen != undefined) btn.moveTweeen.kill();
        },
        onCompleteParams: [s.shiftColBtns[j]]
      });
    }

    for (var i = 0; i < gameLogic.m * 2; i++) {
      s.shiftRowBtns[i].disable();
      TweenMax.to(s.shiftRowBtns[i], 0.5, {
        pixi: {
          alpha: 0
        },
        //delay: (j % gameLogic.n) * 0.1,
        onComplete: function onComplete(btn) {
          if (btn.moveTweeen != undefined) btn.moveTweeen.kill();
        },
        onCompleteParams: [s.shiftRowBtns[i]]
      });
    }

    for (var i = 0; i < gameLogic.m; i++) {
      for (var j = 0; j < gameLogic.n; j++) {
        TweenMax.to(gameLogic.numbers[i][j].gemSprite, 0.5, {
          pixi: {
            alpha: 1
          },
          delay: 0
        });
      }
    }

    TweenMax.to(s.numbersContainer, 0.25, {
      pixi: {
        scale: 1
      },
      ease: Power2.easeOut,
      delay: 0.5
    }); //    for (var i = 0; i < s.powerUpBtns.length; i++) {
    //        TweenMax.to(s.powerUpBtns[i], 0.25, {
    //            pixi: {
    //                y: 0
    //            },
    //            ease: Power2.easeOut,
    //            delay: 0.5
    //        });
    //    }
    //
    //    TweenMax.to(s.shiftDoneBtn, 0.25, {
    //        pixi: {
    //            y: s.shiftDoneBtn.stY
    //        },
    //        ease: Power2.easeIn,
    //
    //    });
  };

  gameScreen.openMenu = function () {
    if (gameLogic.gameOver || gameLogic.paused || gameLogic.shifting) return;
    gameScreen.menuOpened = true;
    gameLogic.lock = true;
    gameLogic.paused = true;
    ads.gameplayStop();
    playSound("btnClick");
    var p = alertPopup();
    var titleTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 90,
      fill: [primaryPalette[1]],
      align: "center"
    });
    var title = new Text(p.content, "Gem·11", titleTextStyle);
    title.setTransform(0, -400);
    var playBtn = new Button(p.content, "", ["play.png"], function () {
      closePopup();
      gameScreen.menuOpened = false;

      p.closeCallback = function () {
        gameLogic.lock = false;
        gameLogic.paused = false;
      };

      playBtn.disable();
      ads.gameplayStart();
    }, PLAY_BUTTON, ["Space", "Enter", "Escape"]);
    playBtn.setTransform(0, -120);
    playBtn.img.setTransform(15, 0);
    var iconsBtns = [];
    var restartBtn = new Button(p.content, "", ["undo-alt.png"], function () {
      gameLogic.clearState();
      setTimeout(gameScreen.clearLevel, 750);
      gameLogic.lock = true;
      gameLogic.shifting = false;
      closePopup();
      gameScreen.menuOpened = false;
      restartBtn.disable();
      ads.showAd(ads.gameplayStart);
    }, ICON_BUTTON, ["KeyR"]);
    iconsBtns.push(restartBtn);

    if (tutorial.isDrawn) {
      restartBtn.disable();
      restartBtn.alpha = 0.3;
    } //setInterval(playBtn.callback, 3000);


    var img = "volume-down.png";
    if (!soundOn) img = "volume-mute.png";
    var soundBtn = new Button(p.content, "", img, function () {
      toggleSound();

      if (soundOn) {
        soundBtn.setImg("volume-down.png");
      } else {
        soundBtn.setImg("volume-mute.png");
      }
    }, ICON_BUTTON, ["KeyM"]);
    iconsBtns.push(soundBtn);
    arrangeToGrid(iconsBtns, 1, 2, 0, 0, 0, 150);
    var selOffset = 25;
    gameScreen.langSelection = new Container(p.content);
    gameScreen.langSelection.circle = new Circle(gameScreen.langSelection, 50);
    gameScreen.langSelection.sprite = new Sprite(gameScreen.langSelection, "check.png");
    var langBtns = [];
    var langIndex = 0;
    var i = 0;

    for (var lang in localization) {
      var btn = new Button(p.content, "", lang + ".png", function () {
        setLanguage(this.lang);
        gameScreen.nextText.text = getText("next");
        gameScreen.powerUpBtns[0].setText("powerUpTitle0");
        gameScreen.powerUpBtns[1].setText("powerUpTitle1");
        gameScreen.powerUpBtns[2].setText("powerUpTitle2");
        gameScreen.langSelection.setTransform(this.x + selOffset, this.y + selOffset);
      }, LANG_BUTTON);
      btn.lang = lang;
      langBtns.push(btn);

      if (lang === language) {
        langIndex = i;
      }

      i++;
    }

    arrangeToGrid(langBtns, 2, Math.ceil(langBtns.length / 2), -10, -10, 0, 350, null, null, null, true, true);
    gameScreen.langSelection.setTransform(langBtns[langIndex].x + selOffset, langBtns[langIndex].y + selOffset, 0.25);
    p.content.toFront(gameScreen.langSelection); //var btnGroup = new ButtonGroup(langBtns, langIndex);
    //setTimeout(drawGuideLines());
    //    var share = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.shareText(getText("share"));
    //
    //        }
    //    }
    //
    //    var shareBtn = new Button(p.content, "", "share.png", share, ICON_BUTTON);
    //    shareBtn.setTransform(200, 350);
    //
    //
    //
    //    var signInOut = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.signInOut();
    //        }
    //
    //        gameScreen.signInOutBtn.disable();
    //    }
    //
    //    var img = "googleSignIn.png"
    //    if (!signing.signedIn)
    //        img = "googleSignOut.png"
    //
    //    gameScreen.signInOutBtn = new Button(p.content, "", img, signInOut, ICON_BUTTON);
    //    gameScreen.signInOutBtn.setTransform(-200, 475);
    //
    //
    //
    //    var showAchievements = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showAchievements();
    //        }
    //    }
    //
    //
    //    var showLeaderboard = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showLeaderboard(0);
    //        }
    //    }
    //
    //    var leaderboardBtn = new Button(p.content, "", "leaderboard.png", showLeaderboard, ICON_BUTTON);
    //    leaderboardBtn.setTransform(0, 475);
    //
    //    var showAchievements = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showAchievements();
    //        }
    //    }
    //    var achievementsBtn = new Button(p.content, "", "achievements.png", showAchievements, ICON_BUTTON);
    //    achievementsBtn.setTransform(200 , 475);
  };

  gameScreen.onSignIn = function () {
    if (gameScreen.menuOpened) {
      gameScreen.signInOutBtn.enable();
      gameScreen.signInOutBtn.setImg("googleSignIn.png");
    }
  };

  gameScreen.onSignInError = function () {
    if (gameScreen.menuOpened) {
      gameScreen.signInOutBtn.enable();
    }
  };

  gameScreen.onSignOut = function () {
    if (gameScreen.menuOpened) {
      gameScreen.signInOutBtn.enable();
      gameScreen.signInOutBtn.setImg("googleSignOut.png");
    }
  };

  gameScreen.onSignOutError = function () {
    if (gameScreen.menuOpened) {
      gameScreen.signInOutBtn.enable();
    }
  };

  gameScreen.openGameOver = function () {
    gameLogic.clearState();
    analyticsCustiomEvent("Score", gameLogic.score);

    if (window.JSInterface != undefined) {
      window.JSInterface.submitScore(0, gameLogic.score);
    }

    ads.gameplayStop();
    var p = alertPopup();
    var scoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 150,
      fill: [primaryPalette[1]],
      align: "center"
    });
    var bestScoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 30,
      fill: [primaryPalette[1]],
      align: "right"
    });
    var score = new Text(p.content, "0", scoreTextStyle);
    TweenMax.to(score, 0.3, {
      pixi: {
        y: -225
      },
      delay: 2.75,
      ease: Power2.easeInOut
    });
    var bestScore = new Text(p.content, gameLogic.bestScore, bestScoreTextStyle);
    bestScore.anchor.set(1, 0.5);
    var trophySprite = new Sprite(p.content, "trophy.png");
    trophySprite.anchor.set(0, 0.5);
    trophySprite.scale.set(1.1);
    var gap = 4;
    bestScore.setTransform(bestScore.width / 2 - trophySprite.width / 2 - gap / 2, -125);
    trophySprite.setTransform(bestScore.x + gap, bestScore.y);
    bestScore.alpha = 0;
    trophySprite.alpha = 0;
    TweenMax.to([bestScore, trophySprite], 0.2, {
      pixi: {
        alpha: 1
      },
      delay: 3.1
    }); //drawGuideLines();

    var timeout = setTimeout(countText, 750, score, 0, gameLogic.score, 1500, ["scoreCount"]);
    var resetBtnTimeout = setTimeout(function () {
      var restartBtn = new Button(p.content, "", ["undo-alt.png"], function () {
        setTimeout(gameScreen.clearLevel, 1000);
        gameLogic.lock = true;
        closePopup();
        clearTimeout(timeout);
        restartBtn.disable();
        ads.showAd(ads.gameplayStart);
      }, RESTART_BUTTON, ["Space", "Enter", "Escape", "KeyR"]);
      restartBtn.setTransform(0, 60);
      restartBtn.alpha = 0;
      restartBtn.scale.set(0.5);
      TweenMax.to(restartBtn, 0.3, {
        pixi: {
          scale: 1,
          alpha: 1
        },
        delay: 0,
        ease: Back.easeOut.config(1.7)
      });
      var socialBtns = [];
      var socialContainer = new Container(p.content);
      socialContainer.visible = false;
      socialContainer.setTransform(0, 275);

      var socialShare = function socialShare(e) {
        shareToSocial[this.platform](getText("shareScore", [gameLogic.score]), ads.shareableURL);
      };

      for (var key in shareToSocial) {
        var btn = new Button(socialContainer, "", key + ".png", socialShare, ICON_BUTTON);
        btn.platform = key;
        socialBtns.push(btn);
      }

      var share = function share() {
        if (false) {
          shareOnMobile(getText("shareScore", [gameLogic.score]), ads.shareableURL);
        } else {
          socialContainer.visible = true;
          socialContainer.alpha = 0;
          shareBtn.disable();
          TweenMax.to(socialContainer, 0.33, {
            pixi: {
              alpha: 1
            },
            ease: Power2.easeOut
          });
          TweenMax.to(shareBtn, 0.33, {
            pixi: {
              alpha: 0
            },
            ease: Power2.easeOut
          });
          arrangeToGrid(socialBtns, 1, socialBtns.length, 0, 0, 0, 0, 0.2, 0, 0, Back.easeOut, true);
        }
      };

      var shareBtn = new Button(p.content, "", "share.png", share, ICON_BUTTON);
      shareBtn.setTransform(0, 275);
      shareBtn.alpha = 0;
      shareBtn.scale.set(0.75);
      TweenMax.to(shareBtn, 0.3, {
        pixi: {
          scale: 1,
          alpha: 1
        },
        delay: 0.1,
        ease: Back.easeOut.config(1.7)
      });
    }, 3200); //    var showLeaderboard = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showLeaderboard(0);
    //        }
    //    }
    //    var leaderboardBtn = new Button(p.content, "", "leaderboard.png", showLeaderboard, ICON_BUTTON);
    //    leaderboardBtn.setTransform(-150, 350);
    //    leaderboardBtn.alpha = 0;
    //    leaderboardBtn.scale.set(0.5);
    //    TweenMax.to(leaderboardBtn, 0.3, {
    //        pixi: {
    //            scale: 1,
    //            alpha: 1,
    //        },
    //        delay: 3.3,
    //        ease: Back.easeOut.config(1.7),
    //    });
    //
    //    var showAchievements = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showAchievements();
    //        }
    //    }
    //    var achievementsBtn = new Button(p.content, "", "achievements.png", showAchievements, ICON_BUTTON);
    //    achievementsBtn.setTransform(0, 350);
    //    achievementsBtn.alpha = 0;
    //    achievementsBtn.scale.set(0.5);
    //    TweenMax.to(achievementsBtn, 0.3, {
    //        pixi: {
    //            scale: 1,
    //            alpha: 1,
    //        },
    //        delay: 3.4,
    //        ease: Back.easeOut.config(1.7),
    //    });
    //
    //    var share = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.shareText(getText("shareScore", [gameLogic.score]));
    //
    //        }
    //    }
    //
    //    var shareBtn = new Button(p.content, "", "share.png", share, ICON_BUTTON);
    //    shareBtn.setTransform(150, 350);
    //    shareBtn.alpha = 0;
    //    shareBtn.scale.set(0.5);
    //    TweenMax.to(shareBtn, 0.3, {
    //        pixi: {
    //            scale: 1,
    //            alpha: 1,
    //        },
    //        delay: 3.5,
    //        ease: Back.easeOut.config(1.7),
    //    });
  };

  gameScreen.openWin = function (value, level, i, j) {
    gameLogic.clearState();
    analyticsCustiomEvent("Win");
    analyticsCustiomEvent("Score", gameLogic.score);

    if (window.JSInterface != undefined) {
      window.JSInterface.submitScore(0, gameLogic.score);
    }

    ads.gameplayStop();
    var p = alertPopup();
    var scoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 150,
      fill: [primaryPalette[1]],
      align: "center"
    });
    var bestScoreTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 30,
      fill: [primaryPalette[1]],
      align: "right"
    });
    var mainDelay = 7.5;
    var gem = new NumberShape(p.content, value, level);
    TweenMax.to(gem, 0.3, {
      pixi: {
        alpha: 0,
        scale: 0.5
      },
      delay: mainDelay - 0.4,
      ease: Back.easeIn.config(1.7)
    });
    playSound("win");
    setTimeout(fadeToColor, mainDelay * 1000, p.overlay, 0xffffff, 0.99, 1000);
    setTimeout(function (v, l, i, j) {
      gameLogic.numbers[i][j] = new NumberShape(gameScreen.numbersContainer, v, l);
      gameLogic.numbers[i][j].position = gameScreen.getNumberPos(i, j);
      gameLogic.numbers[i][j].i = i;
      gameLogic.numbers[i][j].j = j;
    }, mainDelay * 1000, value, level, i, j);
    var score = new Text(p.content, "0", scoreTextStyle);
    score.alpha = 0;
    score.scale.set(0.5);
    TweenMax.to(score, 0.2, {
      pixi: {
        alpha: 1,
        scale: 1
      },
      delay: mainDelay,
      ease: Power2.easeInOut
    });
    TweenMax.to(score, 0.3, {
      pixi: {
        y: -225
      },
      delay: 2.75 + mainDelay,
      ease: Power2.easeInOut
    });
    var bestScore = new Text(p.content, gameLogic.bestScore, bestScoreTextStyle);
    bestScore.anchor.set(1, 0.5);
    var trophySprite = new Sprite(p.content, "trophy.png");
    trophySprite.anchor.set(0, 0.5);
    trophySprite.scale.set(1.1);
    var gap = 4;
    bestScore.setTransform(bestScore.width / 2 - trophySprite.width / 2 - gap / 2, -125);
    trophySprite.setTransform(bestScore.x + gap, bestScore.y);
    bestScore.alpha = 0;
    trophySprite.alpha = 0;
    TweenMax.to([bestScore, trophySprite], 0.2, {
      pixi: {
        alpha: 1
      },
      delay: 3.1 + mainDelay
    });
    var timeout = setTimeout(countText, 750 + mainDelay * 1000, score, 0, gameLogic.score, 1500, ["scoreCount"]);
    setTimeout(function () {
      var restartBtn = new Button(p.content, "", ["undo-alt.png"], function () {
        setTimeout(gameScreen.clearLevel, 1000);
        gameLogic.lock = true;
        closePopup();
        clearTimeout(timeout);
        restartBtn.disable();
        ads.showAd();
        ads.gameplayStart();
      }, RESTART_BUTTON, ["KeyR", "Enter", "Space", "Escape"]);
      restartBtn.setTransform(0, 60);
      restartBtn.alpha = 0;
      restartBtn.scale.set(0.5);
      TweenMax.to(restartBtn, 0.3, {
        pixi: {
          scale: 1,
          alpha: 1
        },
        delay: 0,
        ease: Back.easeOut.config(1.7)
      });
      var socialBtns = [];
      var socialContainer = new Container(p.content);
      socialContainer.visible = false;
      socialContainer.setTransform(0, 275);

      var socialShare = function socialShare(e) {
        shareToSocial[this.platform](getText("shareScore", [gameLogic.score]), ads.shareableURL);
      };

      for (var key in shareToSocial) {
        var btn = new Button(socialContainer, "", key + ".png", socialShare, ICON_BUTTON);
        btn.platform = key;
        socialBtns.push(btn);
      }

      var share = function share() {
        if (is.mobile()) {
          shareOnMobile(getText("shareScore", [gameLogic.score]), ads.shareableURL);
        } else {
          socialContainer.visible = true;
          socialContainer.alpha = 0;
          shareBtn.disable();
          TweenMax.to(socialContainer, 0.33, {
            pixi: {
              alpha: 1
            },
            ease: Power2.easeOut
          });
          TweenMax.to(shareBtn, 0.33, {
            pixi: {
              alpha: 0
            },
            ease: Power2.easeOut
          });
          arrangeToGrid(socialBtns, 1, socialBtns.length, 0, 0, 0, 0, 0.2, 0, 0, Back.easeOut, true);
        }
      };

      var shareBtn = new Button(p.content, "", "share.png", share, ICON_BUTTON);
      shareBtn.setTransform(0, 275);
      shareBtn.alpha = 0;
      shareBtn.scale.set(0.75);
      TweenMax.to(shareBtn, 0.3, {
        pixi: {
          scale: 1,
          alpha: 1
        },
        delay: 0.1,
        ease: Back.easeOut.config(1.7)
      });
    }, (3.2 + mainDelay) * 1000); //    var showLeaderboard = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showLeaderboard(0);
    //        }
    //    }
    //    var leaderboardBtn = new Button(p.content, "", "leaderboard.png", showLeaderboard, ICON_BUTTON);
    //    leaderboardBtn.setTransform(-150, 350);
    //    leaderboardBtn.alpha = 0;
    //    leaderboardBtn.scale.set(0.5);
    //    TweenMax.to(leaderboardBtn, 0.3, {
    //        pixi: {
    //            scale: 1,
    //            alpha: 1,
    //        },
    //        delay: 3.3 + mainDelay,
    //        ease: Back.easeOut.config(1.7),
    //    });
    //
    //    var showAchievements = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.showAchievements();
    //        }
    //    }
    //    var achievementsBtn = new Button(p.content, "", "achievements.png", showAchievements, ICON_BUTTON);
    //    achievementsBtn.setTransform(0, 350);
    //    achievementsBtn.alpha = 0;
    //    achievementsBtn.scale.set(0.5);
    //    TweenMax.to(achievementsBtn, 0.3, {
    //        pixi: {
    //            scale: 1,
    //            alpha: 1,
    //        },
    //        delay: 3.4 + mainDelay,
    //        ease: Back.easeOut.config(1.7),
    //    });
    //
    //    var share = function () {
    //        if (window.JSInterface != undefined) {
    //            window.JSInterface.shareText(getText("shareScore", [gameLogic.score]));
    //
    //        }
    //    }
    //
    //    var shareBtn = new Button(p.content, "", "share.png", share, ICON_BUTTON);
    //    shareBtn.setTransform(150, 350);
    //    shareBtn.alpha = 0;
    //    shareBtn.scale.set(0.5);
    //    TweenMax.to(shareBtn, 0.3, {
    //        pixi: {
    //            scale: 1,
    //            alpha: 1,
    //        },
    //        delay: 3.5 + mainDelay,
    //        ease: Back.easeOut.config(1.7),
    //    });
  };

  gameScreen.openPowerUpInfo = function (index) {
    if (gameLogic.paused) {
      return;
    }

    gameLogic.lock = true;
    gameLogic.paused = true;
    ads.gameplayStop();
    var p = alertPopup();
    var titleTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 80,
      fill: [primaryPalette[1]],
      align: "center"
    });
    var infoTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 40,
      fill: [primaryPalette[1]],
      align: "center",
      wordWrap: true,
      wordWrapWidth: 1000
    });
    var msgTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 35,
      fill: [primaryPalette[1]],
      align: "center",
      wordWrap: true,
      wordWrapWidth: 1000
    });
    var title = new Text(p.content, getText("powerUpTitle" + index), titleTextStyle);
    title.setTransform(0, -350);
    var img = new Sprite(p.content, "PU_" + index + ".png");
    img.setTransform(0, title.y / 2, 1.5, 1.5);
    var info = new Text(p.content, getText("powerUpText" + index), infoTextStyle);
    info.setTransform(0, -45);
    info.anchor.set(0.5, 0);

    if (ads.getWaitingTime() === 0) {
      var msg = new Text(p.content, getText("ad"), msgTextStyle);
      msg.setTransform(0, info.y + info.height + 40);
    }

    var okBtn = new SpriteButton(p.content, null, "check.png", true, [2, 2], ["Space", "Enter"]);
    okBtn.setTransform(100, -title.y, 0.5, 0.5);

    okBtn.callback = function () {
      playSound("btnClick");
      gameLogic.lastPowerUp = index;
      closePopup();
      okBtn.disable();
      closeBtn.disable();

      if (isConnected()) {
        ads.showRewardedVideo(gameLogic.powerUpName[index], ads.gameplayStart);
      } else {
        p.closeCallback = function () {
          gameScreen.openWarning("noInternetTitle", "noInternetText");
        };
      }

      gameLogic.paused = false;
    };

    var closeBtn = new SpriteButton(p.content, null, "close.png", true, [1.5, 1.5], ["Escape"]);
    closeBtn.setTransform(-okBtn.x, okBtn.y, 0.5, 0.5);

    closeBtn.callback = function () {
      playSound("btnClick");
      closePopup();
      ads.gameplayStart();
      okBtn.disable();
      closeBtn.disable();

      if (index == gameLogic.PU_UNDO) {
        gameLogic.gameOver = true;
        gameLogic.lock = true;

        p.closeCallback = function () {
          gameScreen.openGameOver();
        };

        setTimeout(gameLogic.clearState, 50);
      } else {
        p.closeCallback = function () {
          gameLogic.lock = false;
        };
      }

      gameLogic.paused = false;
    };
  };

  gameScreen.openWarning = function (title, text) {
    if (gameLogic.gameOver) return;
    ads.gameplayStop();
    var p = alertPopup();
    var titleTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 80,
      fill: [primaryPalette[1]],
      align: "center"
    });
    var infoTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-bold",
      fontSize: 40,
      fill: [primaryPalette[1]],
      align: "center",
      wordWrap: true,
      wordWrapWidth: 650
    });
    var msgTextStyle = new PIXI.TextStyle({
      fontFamily: "manrope-medium",
      fontSize: 35,
      fill: [primaryPalette[1]],
      align: "center",
      wordWrap: true,
      wordWrapWidth: 1000
    });
    var title = new Text(p.content, getText(title), titleTextStyle);
    title.setTransform(0, -350);
    var img = new Sprite(p.content, "warning.png");
    img.setTransform(0, title.y / 2, 1.25, 1.25);
    var info = new Text(p.content, getText(text), infoTextStyle);
    info.setTransform(0, -45);
    info.anchor.set(0.5, 0);
    var okBtn = new SpriteButton(p.content, null, "check.png", true, [2, 2], ["Space", "Enter"]);
    okBtn.setTransform(0, -title.y, 0.5, 0.5);

    okBtn.callback = function () {
      playSound("btnClick");
      closePopup();
      gameLogic.lock = false;
      okBtn.disable();

      p.closeCallback = function () {
        gameScreen.openPowerUpInfo(gameLogic.lastPowerUp);
      };
    };
  };

  gameScreen.showBgGlow = function () {
    TweenMax.to(gameScreen.bgGlow, 3, {
      pixi: {
        alpha: 1
      }
    });
    TweenMax.to(gameScreen.dust, 3, {
      pixi: {
        alpha: 1
      }
    });

    if (tutorial.isDrawn) {
      tutorial.handContainer.scale.set(0.5);
      TweenMax.to(tutorial.handContainer, 0.5, {
        pixi: {
          alpha: 1,
          scale: 1
        },
        ease: Back.easeOut.config(1.7),
        onComplete: tutorial.playStep
      });
    }
  }; //resize


  gameScreen.resize = function () {
    var s = gameScreen;

    if (!s.isDrawn) {
      return;
    }

    if (!s.root.visible) {
      return;
    }

    var w = APP.screen.width;
    var h = APP.screen.height;
    s.background.width = w;
    s.background.height = h;
    s.backgroundBlack.width = w;
    s.backgroundBlack.height = h;
    s.bgGlow.setTransform(w / 2, h / 2, ratio_scale, ratio_scale);
    s.bgGlowBlack.setTransform(w / 2, h / 2, ratio_scale, ratio_scale);
    s.nextNumContainer.scale.set(ratio_scale);
    s.nextNumContainer.setTransform(w / 2, s.nextNumContainer.height / 2 + 50 * ratio_scale);
    s.scoreContainer.setTransform(w - 40 * ratio_scale, 30 * ratio_scale, ratio_scale, ratio_scale);
    s.menuBtnContainer.setTransform(40 * ratio_scale, 40 * ratio_scale, ratio_scale, ratio_scale); //landscape (16:9)

    if (currentFormat == LANDSCAPE) {
      gameLogic.selectionCorrection = -1;
      s.numbersContainer.rotation = degToRad(90);
      s.bgGlow.rotation = degToRad(90);
      s.bgGlowBlack.rotation = degToRad(90);
      s.numContParent.setTransform(w / 2, h / 2 - 25 * ratio_scale, ratio_scale * 0.85, ratio_scale * 0.85);
      s.powerUpContainer.setTransform(w / 2, h - 75 * ratio_scale, ratio_scale * 0.9, ratio_scale * 0.9);
    } //portrait (9:16)
    else if (currentFormat == PORTRAIT) {
        gameLogic.selectionCorrection = 1;
        s.numbersContainer.rotation = degToRad(0);
        s.bgGlow.rotation = degToRad(0);
        s.bgGlowBlack.rotation = degToRad(0);
        s.numContParent.setTransform(w / 2, h / 2, ratio_scale, ratio_scale);

        if (w / h > 0.85) {
          s.numContParent.setTransform(w / 2, h / 2, ratio_scale * 0.66, ratio_scale * 0.66);
        } else {
          if (w / h > 0.7) {
            s.numContParent.setTransform(w / 2, h / 2, ratio_scale * 0.8, ratio_scale * 0.8);
          }
        }

        if (w / h < 0.66) {
          s.powerUpContainer.setTransform(w / 2, h - 100 * ratio_scale, ratio_scale * 0.9, ratio_scale * 0.9);
        } else {
          s.powerUpContainer.setTransform(w / 2, h - 75 * ratio_scale, ratio_scale * 0.9, ratio_scale * 0.9);
        }
      } //desktop (4:3)
      else if (currentFormat == DESKTOP) {
          gameLogic.selectionCorrection = -1;
          s.numbersContainer.rotation = degToRad(90);
          s.bgGlow.rotation = degToRad(90);
          s.bgGlowBlack.rotation = degToRad(90);
          s.numContParent.setTransform(w / 2, h / 2, ratio_scale * 0.85, ratio_scale * 0.85);
          s.powerUpContainer.setTransform(w / 2, h - 75 * ratio_scale, ratio_scale * 0.9, ratio_scale * 0.9);
        }

    if (gameLogic.numbers[0]) {
      for (var i = 0; i < gameLogic.m; i++) {
        for (var j = 0; j < gameLogic.n; j++) {
          gameLogic.numbers[i][j].rotation = -s.numbersContainer.rotation;
        }
      }
    }

    s.selectionCircle.position = s.getNumberPos(s.selectionCircle.i, s.selectionCircle.j);
  };

  resize_methods.push(gameScreen.resize); //delete

  gameScreen["delete"] = function () {
    gameScreen.root["delete"]();
    gameScreen.isDrawn = false;
  };

  function startGame() {
    gameScreen.draw();
    keyboardControls.addDownEvent(["ArrowLeft"], gameLogic.moveSelection, [0, -1]);
    keyboardControls.addDownEvent(["ArrowRight"], gameLogic.moveSelection, [0, 1]);
    keyboardControls.addDownEvent(["ArrowUp"], gameLogic.moveSelection, [-1, 0]);
    keyboardControls.addDownEvent(["ArrowDown"], gameLogic.moveSelection, [1, 0]);
    keyboardControls.addDownEvent(["Space", "Enter"], gameLogic.selectNumber);
    keyboardControls.addUpEvent(["Space", "Enter"], gameLogic.unselectNumber);
  }

  var gameLogic = {};
  gameLogic.selectedNumbers = [];
  gameLogic.m = 4;
  gameLogic.n = 3;
  gameLogic.wildBonus = 25;
  gameLogic.numbers = [];
  gameLogic.currentLevel = 0;
  gameLogic.maxLevel = 0;
  gameLogic.lock = false;
  gameLogic.shiftColLock = [];

  for (var i = 0; i < gameLogic.n; i++) {
    gameLogic.shiftColLock[i] = false;
  }

  gameLogic.shiftRowLock = [];

  for (var i = 0; i < gameLogic.m; i++) {
    gameLogic.shiftRowLock[i] = false;
  }

  gameLogic.shifting = false;
  gameLogic.boardStates = [];
  gameLogic.numOfSaveStates = 20;
  gameLogic.stateIndex = 0;
  gameLogic.bestScore = 0;
  gameLogic.seenTutorial = false;
  gameLogic.activePowerUps = [];
  gameLogic.lastPowerUp = null;
  gameLogic.PU_1to2 = 0;
  gameLogic.PU_WILD = 1;
  gameLogic.PU_SHIFT = 2;
  gameLogic.PU_UNDO = 3;
  gameLogic.powerUpName = ["PowerUp1to2", "PowerUpWild", "PowerUpShift", "LastChance"];
  gameLogic.selectionCorrection = 1;
  gameLogic.starValues = [];
  gameLogic.drawIndex = 0;
  gameLogic.drawDeck = [];
  pushElements(gameLogic.drawDeck, 1, 10);
  pushElements(gameLogic.drawDeck, 2, 4);
  pushElements(gameLogic.drawDeck, 3, 1);
  shuffleArray(gameLogic.drawDeck);
  unshiftElements(gameLogic.drawDeck, 1, 5);
  var expTexture;
  var tutStartNumbers = [[1, 1], [2, 2], [1, 2], [-1, -1]];
  var tutEndNumbers = [[1, 2], [1, 2], [0, 2], [-1, -1]];
  var shapeColors = [primaryPalette[0], primaryPalette[1]];
  var numberTextStyles = [];
  numberTextStyles[0] = new PIXI.TextStyle({
    fontFamily: "manrope-medium",
    fontSize: 80,
    fill: [primaryPalette[1]],
    align: "center" //dropShadow: true,
    //dropShadowColor: ['#' + primaryPalette[3].toString(16)]

  });
  numberTextStyles[1] = new PIXI.TextStyle({
    fontFamily: "manrope-medium",
    fontSize: 80,
    fill: [primaryPalette[0]],
    align: "center" //dropShadow: true,
    //dropShadowColor: ['#' + primaryPalette[0].toString(16)]

  });

  gameLogic.levelCompleted = function () {
    gameLogic.lock = true;
    gameLogic.currentLevel++;
    gameLogic.maxLevel = Math.max(gameLogic.maxLevel, gameLogic.currentLevel);
    setTimeout(gameScreen.clearLevel, 1000);
    if (!levels[gameLogic.currentLevel]) gameLogic.generateLevel();
    setTimeout(gameScreen.drawLevel, 1500, levels[gameLogic.currentLevel]);
  };

  gameLogic.levelFailed = function () {
    if (gameLogic.activePowerUps[gameLogic.PU_UNDO] && gameLogic.moveCounter > gameLogic.numOfSaveStates * 2) {
      gameLogic.lock = true;
      gameLogic.gameOver = true;
      setTimeout(shakeScreen, 1000, 10, 1500, gameScreen.numbersContainer);
      setTimeout(playSound, 1000, "shake");
      setTimeout(gameScreen.openPowerUpInfo, 2500, gameLogic.PU_UNDO);
    } else {
      gameLogic.lock = true;
      gameLogic.gameOver = true;
      setTimeout(gameScreen.updatePowerUps, 500);
      setTimeout(shakeScreen, 1000, 5, 1500, gameScreen.numbersContainer);
      setTimeout(playSound, 1000, "shake");
      setTimeout(gameScreen.openGameOver, 2500);
      setTimeout(gameLogic.clearState, 50);
    } //gameScreen.lastScreenshot = captureScreen();

  };

  gameLogic.resetGame = function (shuffle) {
    if (shuffle == undefined) shuffle = true;
    gameLogic.moveCounter = 0;
    gameLogic.boardMax = 3;
    gameLogic.score = 0;
    gameLogic.updateScore(0);
    gameLogic.drawIndex = 0;
    if (shuffle) shuffleArray(gameLogic.drawDeck);
    gameLogic.setNextValue();
    gameLogic.lock = false;
    gameLogic.paused = false;
    gameLogic.shiftColLock = [];

    for (var i = 0; i < gameLogic.n; i++) {
      gameLogic.shiftColLock[i] = false;
    }

    gameLogic.shiftRowLock = [];

    for (var i = 0; i < gameLogic.m; i++) {
      gameLogic.shiftRowLock[i] = false;
    }

    gameLogic.shifting = false;
    gameLogic.xGem = false;
    gameLogic.gameOver = false;
    gameLogic.activePowerUps = [true, true, true, true];
    gameLogic.lastPowerUp = null;
    gameScreen.updatePowerUps(); //if (shuffle)
    //  gameScreen.hideLastChance();
  };

  gameLogic.saveState = function (replaceLastState) {
    var state = {};
    state.matrix = [];

    for (var i = 0; i < gameLogic.m; i++) {
      state.matrix[i] = [];

      for (var j = 0; j < gameLogic.n; j++) {
        state.matrix[i][j] = {};
        state.matrix[i][j].v = gameLogic.numbers[i][j].value;
        state.matrix[i][j].l = gameLogic.numbers[i][j].level;
      }
    }

    state.drawDeck = gameLogic.drawDeck;
    state.drawIndex = gameLogic.drawIndex;
    state.score = gameLogic.score;
    state.moveCounter = gameLogic.moveCounter;
    state.nextValue = gameLogic.nextValue;
    state.boardMax = gameLogic.boardMax;
    state.shifting = gameLogic.shifting;
    state.activePowerUps = gameLogic.activePowerUps;

    if (!replaceLastState) {
      for (var i = gameLogic.numOfSaveStates - 2; i >= 0; i--) {
        saveObject("state" + (i + 1), loadObject("state" + i));
      }
    }

    saveObject("state0", state);
  };

  gameLogic.loadState = function () {
    var bs = loadObject("bestScore");

    if (bs) {
      gameLogic.bestScore = bs;
      gameScreen.bestScoreText.text = gameLogic.bestScore + "";
    }

    var state = loadObject("state0");

    if (state) {
      gameLogic.boardMax = state.boardMax;
      gameLogic.nextValue = state.nextValue;
      gameScreen.updateNextValue(gameLogic.nextValue);
      gameLogic.score = state.score;
      gameLogic.moveCounter = state.moveCounter;
      gameLogic.updateScore(0);
      gameLogic.drawDeck = state.drawDeck;
      gameLogic.drawIndex = state.drawIndex;

      if (state.drawIndex > 0) {
        gameScreen.updateProgress((gameLogic.drawIndex - 1) / gameLogic.drawDeck.length);
      } else {
        gameScreen.updateProgress(1);
      }

      gameScreen.drawLevel(state, false);
      gameLogic.activePowerUps = state.activePowerUps;
      gameScreen.updatePowerUps();

      if (state.shifting) {
        gameLogic.startShifting();
      } else {
        if (!gameLogic.checkConditions()) {
          gameLogic.levelFailed();
        }
      }

      return true;
    } else return false;
  };

  gameLogic.revive = function () {
    saveObject("state0", loadObject("state" + (gameLogic.numOfSaveStates - 1)));
    gameLogic.loadState();
    gameLogic.activePowerUps[gameLogic.PU_UNDO] = false;
    gameLogic.lock = false;
  };

  gameLogic.clearState = function () {
    for (var i = 0; i < gameLogic.numOfSaveStates; i++) {
      localStorage.removeItem("state" + i);
      saveObject("state" + i, null);
    }
  };

  gameLogic.checkConditions = function () {
    var s = gameScreen;
    var markedNumbers = [];

    for (var i = 0; i < gameLogic.m; i++) {
      for (var j = 0; j < gameLogic.n; j++) {
        if (gameLogic.numbers[i][j]) {
          markedNumbers.push(gameLogic.numbers[i][j]);
          j = gameLogic.numbers[i].length;
          i = gameLogic.numbers.length;
        }
      }
    }

    var validMove = false;

    for (var i = 0; i < markedNumbers.length; i++) {
      var neig = markedNumbers[i].getNeighbours();
      var len = neig.length;

      for (var j = 0; j < len; j++) {
        if (markedNumbers.indexOf(neig[j]) == -1) {
          markedNumbers.push(neig[j]);
        }

        if (!validMove) {
          if (markedNumbers[i].canCapture(neig[j])) validMove = true;
        }
      }
    }

    return validMove;
  };

  gameLogic.isThereHope = function () {
    if (gameLogic.activePowerUps[gameLogic.PU_SHIFT]) return true;

    if (gameLogic.activePowerUps[gameLogic.PU_1to2]) {
      for (var i = 0; i < gameLogic.m; i++) {
        for (var j = 0; j < gameLogic.n; j++) {
          if (gameLogic.numbers[i][j].value == 1) {
            var neig = gameLogic.numbers[i][j].getNeighbours();
            var len = neig.length;

            for (var k = 0; k < len; k++) {
              if (neig[k].value == 2) return true;
            }
          }
        }
      }
    }

    return false;
  };

  gameLogic.resetLevel = function () {
    gameLogic.selectedNumbers = [];
    gameLogic.numbers = [];
    gameLogic.lock = false;
  };

  gameLogic.updateLevel = function () {
    for (var i = 0; i < gameLogic.m; i++) {
      for (var j = 0; j < gameLogic.n; j++) {
        if (gameLogic.numbers[i][j]) {
          gameLogic.numbers[i][j].update();
        }
      }
    }
  };

  gameLogic.moveNumber = function (nums) {
    gameLogic.lock = true;
    nums[0].parent.toFront(nums[0]);

    if (tutorial.isDrawn) {
      tutorial.handContainer.parent.toFront(tutorial.handContainer);
    }

    var neig = nums[0].getNeighbours();

    for (var j = 0; j < neig.length; j++) {
      gameScreen.updateDots(nums[0], neig[j], false, false);
    }

    gameLogic.numbers[nums[0].i][nums[0].j] = null;
    var len = nums.length;
    var ease;

    for (var i = 1; i < len; i++) {
      if (len == 2) {
        ease = Power1.easeInOut;
      } else {
        ease = Power0.easeNone;
        if (i == 1) ease = Power1.easeIn;
        if (i == len - 1) ease = Power1.easeOut;
      }

      TweenMax.to(nums[0], 0.2, {
        pixi: {
          x: nums[i].x,
          y: nums[i].y
        },
        delay: (i - 1) * 0.2,
        ease: ease
      });
      TweenMax.to(nums[i].gemSprite, 0.2, {
        pixi: {
          scale: 0.5
        },
        delay: (i - 1) * 0.2,
        ease: Power2.easeOut,
        onComplete: function onComplete(nums, i) {
          if (i < nums.length - 1) {
            var neig = nums[i].getNeighbours(); //                    for (var j = 0; j < neig.length; j++) {
            //                        gameScreen.updateDots(nums[i], neig[j], false, false);
            //                    }

            gameLogic.numbers[nums[i].i][nums[i].j] = null;
          }

          if (nums[i].tween) nums[i].tween.kill();
          var newI = nums[0].i;
          var newJ = nums[0].j;
          gameLogic.numbers[newI][newJ] = new NumberShape(gameScreen.numbersContainer, gameLogic.nextValue);
          gameLogic.numbers[newI][newJ].position = gameScreen.getNumberPos(newI, newJ);
          gameLogic.numbers[newI][newJ].i = newI;
          gameLogic.numbers[newI][newJ].j = newJ;
          gameLogic.numbers[newI][newJ].upDots = nums[0].upDots;
          gameLogic.numbers[newI][newJ].rightDots = nums[0].rightDots;
          gameLogic.numbers[newI][newJ].downDots = nums[0].downDots;
          gameLogic.numbers[newI][newJ].leftDots = nums[0].leftDots;
          gameLogic.numbers[newI][newJ].scale.set(0.5);
          gameLogic.numbers[newI][newJ].alpha = 0; //new number appears

          TweenMax.to(gameLogic.numbers[newI][newJ], 0.2, {
            pixi: {
              scale: 1,
              alpha: 1
            },
            delay: 0.4,
            ease: Power2.easeOut
          });
          nums[0].parent.toFront(nums[0]);

          if (tutorial.isDrawn) {
            tutorial.handContainer.parent.toFront(tutorial.handContainer);
          }

          if (nums[0].value + nums[i].value > 0) {
            var newValue = Math.max(nums[0].value, nums[i].value) + 1;
            nums[0].value = newValue;
            nums[0].level = 0;
            gameLogic.updateScore((newValue - 1) * (newValue - 1));

            if (newValue == 11) {
              gameLogic.lock = true;
              gameLogic.gameOver = true;
              setTimeout(gameLogic.clearState, 50);
              setTimeout(gameScreen.openWin, 500, nums[0].value, nums[0].level, nums[i].i, nums[i].j);
              nums[0].change(-1, 0);
            } else {
              nums[0].change(newValue, 0);
            }
          } else {
            var newLevel = nums[0].level + 1;
            gameLogic.updateScore(newLevel * newLevel * gameLogic.wildBonus);
            nums[0].value = 0;
            nums[0].level = newLevel;

            if (newLevel == 3) {
              gameLogic.lock = true;
              gameLogic.gameOver = true;
              setTimeout(gameLogic.clearState, 50);
              setTimeout(gameScreen.openWin, 500, nums[0].value, nums[0].level, nums[i].i, nums[i].j);
              nums[0].change(-1, 0);
            } else {
              nums[0].change(0, newLevel);
            }
          }

          if (i == nums.length - 1) {
            nums[0].i = nums[i].i;
            nums[0].j = nums[i].j;
            nums[0].upDots = nums[i].upDots;
            nums[0].rightDots = nums[i].rightDots;
            nums[0].downDots = nums[i].downDots;
            nums[0].leftDots = nums[i].leftDots;
            gameLogic.numbers[nums[i].i][nums[i].j] = nums[0];
            nums[i]["delete"]();
            gameLogic.updateLevel();

            if (!gameLogic.gameOver) {
              if (!gameLogic.checkConditions()) {
                gameLogic.levelFailed();
              }
            }

            gameLogic.selectedNumbers = [];
          } else {
            nums[i]["delete"]();
          }

          gameLogic.setNextValue();

          if (tutorial.isDrawn) {
            tutorial.nextStep();
          } else {
            if (!gameLogic.gameOver) gameLogic.saveState();
          }
        },
        onCompleteParams: [nums, i]
      });
    }
  };

  gameLogic.unselectAll = function () {
    for (var i = 0; i < gameLogic.selectedNumbers.length; i++) {
      if (gameLogic.selectedNumbers[i]) gameLogic.selectedNumbers[i].unselect();
    }

    gameScreen.disconnectDots(gameLogic.selectedNumbers);
    gameLogic.selectedNumbers = [];
  };

  gameLogic.setNextValue = function () {
    gameLogic.moveCounter++;

    if (gameLogic.drawIndex >= gameLogic.drawDeck.length) {
      gameLogic.nextValue = 0;
      shuffleArray(gameLogic.drawDeck);
      gameScreen.updateProgress(gameLogic.drawIndex / gameLogic.drawDeck.length);
      gameLogic.drawIndex = 0;
    } else {
      if (gameLogic.drawIndex === 0 || gameLogic.drawIndex === 10) {
        if (gameLogic.moveCounter > 25) {
          setTimeout(ads.showAd, 500);
        }
      }

      gameLogic.nextValue = gameLogic.drawDeck[gameLogic.drawIndex];
      gameScreen.updateProgress(gameLogic.drawIndex / gameLogic.drawDeck.length);
      gameLogic.drawIndex++;
    }

    gameScreen.updateNextValue(gameLogic.nextValue);
  };

  gameLogic.powerUp1to2 = function () {
    var delay = 0;
    var delayInc = 0.1;

    for (var i = 0; i < gameLogic.m; i++) {
      for (var j = 0; j < gameLogic.n; j++) {
        if (gameLogic.numbers[i][j].value == 1) {
          gameLogic.numbers[i][j].value = 2;
          gameLogic.numbers[i][j].change(2, 0, false, delay);
          delay += delayInc;
          setTimeout(playSound, delay * 1000, "scoreCount");
        }
      }
    }

    gameLogic.saveState(true);

    if (!gameLogic.checkConditions()) {
      gameLogic.levelFailed();
    } else {
      setTimeout(function () {
        gameLogic.lock = false;
      }, delay * 1000);
    }
  };

  gameLogic.powerUpWild = function () {
    gameLogic.nextValue = 0;
    gameScreen.updateNextValue(0);
    setTimeout(function () {
      var e = new Waves(gameScreen.nextNumContainer, 75, 3, 3, 1, [0x000000]);
      e.alpha = 0.25;
      gameScreen.nextNumContainer.toBack(e);

      for (var i = 0; i < 3; i++) {
        setTimeout(playSound, 100 + i * 300, "match" + (i + 1));
        setTimeout(playSound, 100 + i * 300, "match" + (i + 2));
        setTimeout(playSound, 100 + i * 300, "match" + (i + 3));
      }
    }, 500);
    gameLogic.saveState(true);
    gameLogic.lock = false;
  };

  gameLogic.shiftColumn = function (col, dir) {
    if (gameLogic.shiftColLock[col]) {
      setTimeout(gameLogic.shiftColumn, 50, col, dir);
      return;
    }

    gameLogic.shiftColLock[col] = true;

    if (dir > 0) {
      var p = gameLogic.numbers[gameLogic.m - 1][col];
      var pVars = {};
      gameLogic.fixNumber(pVars, gameLogic.numbers[0][col]);
    } else {
      var p = gameLogic.numbers[0][col];
      var pVars = {};
      gameLogic.fixNumber(pVars, gameLogic.numbers[gameLogic.m - 1][col]);
    }

    for (var k = 0; k < gameLogic.m - 1; k++) {
      var i = k;
      if (dir < 0) i = gameLogic.m - k - 1;
      gameLogic.fixNumber(gameLogic.numbers[i][col], gameLogic.numbers[i + dir][col]);
    }

    for (var k = gameLogic.m - 2; k >= 0; k--) {
      var i = k;
      if (dir < 0) i = gameLogic.m - k - 1;
      gameLogic.numbers[i + dir][col] = gameLogic.numbers[i][col];
      var newPos = gameScreen.getNumberPos(i + dir, col);
      TweenMax.to(gameLogic.numbers[i + dir][col], 0.1, {
        pixi: {
          x: newPos.x,
          y: newPos.y
        },
        ease: Power2.easeOut,
        delay: 0.05
      });
    }

    gameLogic.fixNumber(p, pVars);

    if (dir > 0) {
      var newPos = gameScreen.getNumberPos(0, col);
      gameLogic.numbers[0][col] = p;
    } else {
      var newPos = gameScreen.getNumberPos(gameLogic.m - 1, col);
      gameLogic.numbers[gameLogic.m - 1][col] = p;
    }

    TweenMax.to(p, 0.1, {
      pixi: {
        scale: 0.75,
        alpha: 0
      },
      ease: Back.easeIn.config(1),
      onComplete: function onComplete() {
        p.position.set(newPos.x, newPos.y);
        TweenMax.to(p, 0.1, {
          pixi: {
            scale: 1,
            alpha: 1
          },
          ease: Back.easeOut.config(1),
          onComplete: function onComplete() {
            gameLogic.shiftColLock[col] = false;
          }
        });
      }
    });
    gameLogic.saveState(true);

    if (!gameLogic.checkConditions()) {
      gameScreen.disableShiftDone();
    } else {
      gameScreen.enableShiftDone();
    }
  };

  gameLogic.shiftRow = function (row, dir) {
    if (gameLogic.shiftRowLock[row]) {
      setTimeout(gameLogic.shiftRow, 50, row, dir);
      return;
    }

    gameLogic.shiftRowLock[row] = true;

    if (dir > 0) {
      var p = gameLogic.numbers[row][gameLogic.n - 1];
      var pVars = {};
      gameLogic.fixNumber(pVars, gameLogic.numbers[row][0]);
    } else {
      var p = gameLogic.numbers[row][0];
      var pVars = {};
      gameLogic.fixNumber(pVars, gameLogic.numbers[row][gameLogic.n - 1]);
    }

    for (var k = 0; k < gameLogic.n - 1; k++) {
      var j = k;
      if (dir < 0) j = gameLogic.n - k - 1;
      gameLogic.fixNumber(gameLogic.numbers[row][j], gameLogic.numbers[row][j + dir]);
    }

    for (var k = gameLogic.n - 2; k >= 0; k--) {
      var j = k;
      if (dir < 0) j = gameLogic.n - k - 1;
      gameLogic.numbers[row][j + dir] = gameLogic.numbers[row][j];
      var newPos = gameScreen.getNumberPos(row, j + dir);
      TweenMax.to(gameLogic.numbers[row][j + dir], 0.1, {
        pixi: {
          x: newPos.x,
          y: newPos.y
        },
        ease: Power2.easeOut,
        delay: 0.05
      });
    }

    gameLogic.fixNumber(p, pVars);

    if (dir > 0) {
      var newPos = gameScreen.getNumberPos(row, 0);
      gameLogic.numbers[row][0] = p;
    } else {
      var newPos = gameScreen.getNumberPos(row, gameLogic.n - 1);
      gameLogic.numbers[row][gameLogic.n - 1] = p;
    }

    TweenMax.to(p, 0.1, {
      pixi: {
        scale: 0.75,
        alpha: 0
      },
      ease: Back.easeIn.config(1),
      onComplete: function onComplete() {
        p.position.set(newPos.x, newPos.y);
        TweenMax.to(p, 0.1, {
          pixi: {
            scale: 1,
            alpha: 1
          },
          ease: Back.easeOut.config(1),
          onComplete: function onComplete() {
            gameLogic.shiftRowLock[row] = false;
          }
        });
      }
    });
    gameLogic.saveState(true);

    if (!gameLogic.checkConditions()) {
      gameScreen.disableShiftDone();
    } else {
      gameScreen.enableShiftDone();
    }
  };

  gameLogic.startShifting = function () {
    if (gameLogic.shifting) return;
    gameLogic.shifting = true;
    gameLogic.lock = true;
    gameScreen.showShiftButtons();
    gameLogic.saveState();

    if (!gameLogic.checkConditions()) {
      gameScreen.disableShiftDone();
    } else {
      gameScreen.enableShiftDone();
    } //gameScreen.hideLastChance(false);


    gameScreen.menuBtn.disable();
    gameScreen.menuBtn.alpha = 0.25;
  };

  gameLogic.stopShifting = function () {
    if (!gameLogic.shifting) return;
    gameLogic.lock = false;
    gameLogic.shifting = false;
    gameScreen.hideShiftButtons();
    gameLogic.saveState(true);
    gameScreen.menuBtn.enable();
    gameScreen.menuBtn.alpha = 1;
  };

  gameLogic.rewardPlayer = function () {
    if (gameLogic.lastPowerUp == gameLogic.PU_1to2) {
      gameLogic.activePowerUps[0] = false;
      gameScreen.updatePowerUps(); //gameScreen.hideLastChance();

      setTimeout(gameLogic.powerUp1to2, 1000);
    }

    if (gameLogic.lastPowerUp == gameLogic.PU_WILD) {
      gameLogic.activePowerUps[1] = false;
      gameScreen.updatePowerUps();
      setTimeout(gameLogic.powerUpWild, 1000);
    }

    if (gameLogic.lastPowerUp == gameLogic.PU_SHIFT) {
      gameLogic.startShifting();
      gameScreen.updatePowerUps();
    }

    if (gameLogic.lastPowerUp == gameLogic.PU_UNDO) {
      gameLogic.gameOver = false;
      gameScreen.clearLevel(true);
    }

    analyticsCustiomEvent(gameLogic.powerUpName[gameLogic.lastPowerUp]);
  };

  gameLogic.fixNumber = function (num, newNum) {
    num.i = newNum.i;
    num.j = newNum.j;
    num.upDots = newNum.upDots;
    num.downDots = newNum.downDots;
    num.rightDots = newNum.rightDots;
    num.leftDots = newNum.leftDots;
  };

  gameLogic.updateScore = function (inc) {
    if (gameLogic.score < 6000 && gameLogic.score + inc >= 6000) {//6000 achievement
    }

    gameLogic.score += inc;
    gameScreen.scoreText.text = gameLogic.score + "";

    if (gameLogic.score >= gameLogic.bestScore) {
      gameLogic.bestScore = gameLogic.score;
      gameScreen.bestScoreText.text = gameLogic.bestScore + "";
      saveObject("bestScore", gameLogic.bestScore);
    }
  };

  function NumberShape(parent, value, level) {
    var t = new Container(parent);
    t.value = value;
    level = level || 0;
    t.level = level;
    t.lock = false;

    if (gameLogic.boardMax < value && gameScreen.root.visible) {
      gameLogic.boardMax = value;
      analyticsCustiomEvent("New gem: " + value);
      if (value < 11) gameLogic.saveState();

      if (window.JSInterface != undefined) {
        window.JSInterface.unlockAchievement("gem" + value);
      }

      if (expTexture == undefined) {
        var rect = new Rectangle(t, [20, 3]);
        expTexture = rect.texture;
        rect.destroy();
      }

      ads.happyTime(value / 11);
      var numOfExp = value;

      if (value == 11) {
        numOfExp = 44;
      } else {
        for (var i = 0; i < value; i++) {
          setTimeout(playSound, 350 + i * 150, "match" + (i + 1));
          setTimeout(playSound, 350 + i * 150, "match" + (i + 5));
        }
      }

      for (var i = 0; i < numOfExp; i++) {
        setTimeout(function (par, tex, angle) {
          if (par) {
            if (par.value < 11) {//setTimeout(playSound,random(100),"fireworks"+(random(3)+1));
            }

            var e = new Explosion(par, 150, tex, par.value, 0.5, [gemColors[par.value]]);
            par.toBack(e);
            if (par.star.parent == par) par.toBack(par.star);
            e.rotation = degToRad(angle);
          }
        }, 300 + i * 150, t, expTexture, i * 180 / value);
      }

      t.star = new Star(t, [120 + 5 * value, 30], value * 3);
      t.toBack(t.star);
      t.star.scale.set(0.5);
      t.star.alpha = 0;
      TweenMax.to(t.star, 0.3, {
        pixi: {
          scale: 1,
          alpha: 0.75
        },
        ease: Power2.easeOut,
        delay: 0.15
      });
      TweenMax.to(t.star, 0.8 + value * 0.15, {
        pixi: {
          rotation: value * 2.5
        },
        ease: Power2.easeInOut
      });
      TweenMax.to(t.star, 0.6, {
        pixi: {
          scale: 0,
          alpha: 0
        },
        ease: Power2.easeIn,
        delay: 0.65 + value * 0.15,
        onComplete: function onComplete(s) {
          s["delete"]();
        },
        onCompleteParams: [t.star]
      });
    }

    if (value == 0 && level > 0 && !gameLogic.xGem && gameScreen.root.visible) {
      if (window.JSInterface != undefined) {
        window.JSInterface.unlockAchievement("wild" + level);
      }

      if (level < 3) {
        for (var i = 0; i < 3; i++) {
          setTimeout(playSound, 0 + i * 300, "match" + (i + level * 3 + 1));
          setTimeout(playSound, 0 + i * 300, "match" + (i + level * 3 + 2));
          setTimeout(playSound, 0 + i * 300, "match" + (i + level * 3 + 3));
        }

        analyticsCustiomEvent("Wild gem: " + (level * 3 + 1) + "-" + (level * 3 + 2) + "-" + (level * 3 + 3));
      } else {
        analyticsCustiomEvent("Wild gem: X");
      }

      setTimeout(function (par) {
        if (par) {
          var numOfWaves = par.level + 2;

          if (par.level == 3) {
            gameLogic.xGem = true;
            numOfWaves = 30;
          }

          var e = new Waves(par, 130, 3, numOfWaves, 1, [wildColors[par.level]]);
          e.alpha = 0.5;
          par.toBack(e);
        }
      }, 250, t);
    }

    t.btnArea = new Circle(t, 150);
    t.selection = new Circle(t, 130, [0, 0, 0], [0xffffff, 0.1]);
    t.selection.alpha = 0;
    t.selection.scale.set(0.5);
    var lineW = 5;

    if (value > 0) {
      t.gemSprite = new Sprite(t, "gem" + value + ".png");
      t.badgeSprite = new Sprite(t, "badge" + value + ".png");
    } else {
      t.gemSprite = new Sprite(t, "gem0_" + level + ".png");
      t.badgeSprite = new Sprite(t, "badge0_" + level + ".png");
    }

    t.badgeSprite.y += 120;
    t.backLine = new Circle(t, 100, [lineW, 0xffffff, 1], [0xffffff, 0]);

    if (t.value > 0) {
      t.selection.tint = gemColors[t.value];
    } else {
      t.selection.tint = wildColors[t.level];
    }

    t.update = function () {}; //t.gemSprite.tint = shapeColors[1];


    t.backLine.tint = shapeColors[1];
    t.backLine.alpha = 0;
    t.btnArea.alpha = 0; //    t.dust = new ShapeDust(t, 7, 2, primaryPalette, 1);
    //    t.dust.mask = t.btnArea;
    //    t.dust.reset();
    //    t.dust.reset();

    var rot = degToRad(0);
    t.numberText = new Text(t, "" + t.value, numberTextStyles[1]);
    t.numberText.alpha = 0;
    t.numberText.rotation = rot; //    t.numberText.delete = function () {
    //        if (this.tween)
    //            this.tween.kill();
    //        this.parent.removeChild(this);
    //        this.destroy(true);
    //    }

    t.select = function (head) {
      if (this.lock || gameLogic.lock) return;

      if (this.selectTween) {
        this.selectTween.kill();
        this.selectionTween.kill();
      }

      if (head) {
        playSound("selectGem");
        this.selectTween = TweenMax.to(this.gemSprite, 0.1, {
          pixi: {
            scale: 1.15
          },
          ease: Power2.easeOut
        });
        this.selectionTween = TweenMax.to(this.selection, 0.1, {
          pixi: {
            scale: 1,
            alpha: 1
          },
          ease: Power2.easeOut
        });
      } else {
        playSound("selectGem");
        this.selectTween = TweenMax.to(this.gemSprite, 0.1, {
          pixi: {
            scale: 0.9
          },
          ease: Power2.easeOut
        });
        this.selectionTween = TweenMax.to(this.selection, 0.1, {
          pixi: {
            scale: 0.8,
            alpha: 1
          },
          ease: Power2.easeOut
        });
      }
    };

    t.unselect = function () {
      if (t.lock || gameLogic.lock) return;

      if (this.selectTween) {
        this.selectTween.kill();
        this.selectionTween.kill();
      }

      this.selectTween = TweenMax.to(this.gemSprite, 0.1, {
        pixi: {
          scale: 1
        },
        delay: 0.1,
        ease: Power2.easeIn
      });
      this.selectionTween = TweenMax.to(this.selection, 0.1, {
        pixi: {
          scale: 0.5,
          alpha: 0
        },
        ease: Power2.easeIn
      });
    };

    t.canCapture = function (numberObj) {
      if (this.value * numberObj.value == 0) {
        var lvl;

        if (this.value + numberObj.value == 0) {
          return this.level == numberObj.level;
        }

        if (this.value == 0) lvl = this.level;else lvl = numberObj.level;
        var min = lvl * 3 + 1;
        var max = lvl * 3 + 3;
        return this.value + numberObj.value >= lvl * 3 + 1 && this.value + numberObj.value <= lvl * 3 + 3;
      } else {
        return this.value == numberObj.value;
      }
    };

    t.getNeighbours = function () {
      var neig = [];
      var i = this.i;
      var j = this.j;
      if (j < gameLogic.n - 1) if (gameLogic.numbers[i][j + 1]) neig.push(gameLogic.numbers[i][j + 1]);
      if (j > 0) if (gameLogic.numbers[i][j - 1]) neig.push(gameLogic.numbers[i][j - 1]);
      if (i < gameLogic.m - 1) if (gameLogic.numbers[i + 1][j]) neig.push(gameLogic.numbers[i + 1][j]);
      if (i > 0) if (gameLogic.numbers[i - 1][j]) neig.push(gameLogic.numbers[i - 1][j]);
      return neig;
    };

    t.change = function (newValue, newLevel, withSound, delay) {
      gameLogic.lock = true;
      if (withSound == undefined) withSound = true;
      delay = delay || 0;

      if (newValue == -1) {
        TweenMax.to(this.badgeSprite, 0.2, {
          pixi: {
            scale: 0.75,
            alpha: 0
          },
          delay: 0.1,
          ease: Back.easeIn.config(1)
        });
      }

      TweenMax.to(this.gemSprite, 0.2, {
        pixi: {
          scale: 0.75,
          alpha: 0
        },
        ease: Back.easeIn.config(1),
        delay: delay,
        onComplete: function onComplete(num, value, level) {
          if (value == -1) {
            return;
          }

          var newNum = new NumberShape(num.parent, value, level);
          newNum.i = num.i;
          newNum.j = num.j;
          newNum.x = num.x;
          newNum.y = num.y;
          newNum.upDots = num.upDots;
          newNum.leftDots = num.leftDots;
          newNum.downDots = num.downDots;
          newNum.rightDots = num.rightDots;
          newNum.badgeSprite.rotation = degToRad(0);
          newNum.badgeSprite.scale.set(1);
          newNum.gemSprite.scale.set(0.75);
          newNum.gemSprite.alpha = 0.5;
          gameLogic.numbers[num.i][num.j] = newNum;
          if (num.tween) num.tween.kill();
          num["delete"]();

          if (newValue > 0 && withSound) {
            var tone3 = newValue + 3;
            var tone2 = tone3 - 1 - random(2);
            var tone1 = tone2 - 1;
            playSound("match" + tone1);
            setTimeout(playSound, 50, "match" + tone2);
            setTimeout(playSound, 100, "match" + tone3);
          }

          TweenMax.to(newNum.badgeSprite, 0.2, {
            pixi: {
              rotation: 0,
              scale: 1
            },
            ease: Back.easeOut.config(1)
          });
          TweenMax.to(newNum.gemSprite, 0.2, {
            pixi: {
              //rotation: 360,
              scale: 1,
              alpha: 1
            },
            ease: Back.easeOut.config(1),
            onComplete: function onComplete() {
              if (!gameLogic.gameOver) {
                gameLogic.lock = false;
              }
            }
          });
        },
        onCompleteParams: [this, newValue, newLevel]
      });
    };

    t.onPointerDown = function (e) {
      if (tutorial.isDrawn) {
        if (this.i != tutStartNumbers[tutorial.currentStep][0] || this.j != tutStartNumbers[tutorial.currentStep][1]) return;
      }

      if (gameLogic.lock) return;

      if (e) {
        gameLogic.hideSelectionCircle(true);
        if (e.data.originalEvent.touches) if (e.data.originalEvent.touches.length > 1) return;
      }

      gameLogic.selectedNumbers = [];
      gameLogic.selectedNumbers.push(this);
      this.select(true);
    };

    t.onPointerMove = function (e) {
      if (tutorial.isDrawn) {
        if (this.i != tutEndNumbers[tutorial.currentStep][0] || this.j != tutEndNumbers[tutorial.currentStep][1]) return;
      }

      if (gameLogic.lock) return;
      var sLen = gameLogic.selectedNumbers.length;
      if (sLen == 0) return;
      var lastS = gameLogic.selectedNumbers[gameLogic.selectedNumbers.length - 1];
      var neig = gameLogic.selectedNumbers[sLen - 1].getNeighbours();

      if (gameLogic.selectedNumbers.indexOf(this) == -1 && neig.indexOf(this) != -1 && gameLogic.selectedNumbers[0].canCapture(this)) {
        if (sLen == 2) return;
        gameLogic.selectedNumbers.push(this);
        this.select(false);
        gameScreen.updateDots(gameLogic.selectedNumbers[sLen - 1], this, true, false);
        return;
      }

      if (gameLogic.selectedNumbers.indexOf(this) == sLen - 2 && sLen > 1) {
        gameScreen.updateDots(gameLogic.selectedNumbers[sLen - 1], this, false, false);
        gameLogic.selectedNumbers.pop().unselect();
      }
    };

    t.onPointerUp = function (e) {
      if (gameLogic.lock) return;

      if (e) {
        if (e.data.originalEvent.touches) if (e.data.originalEvent.touches.length > 0) return;
      }

      var sLen = gameLogic.selectedNumbers.length;
      if (sLen > 0) gameLogic.selectedNumbers[0].unselect();

      if (sLen > 1) {
        gameLogic.moveNumber(gameLogic.selectedNumbers);
      } else {
        gameLogic.selectedNumbers = [];
      }
    };

    if (tutorial.isDrawn) {
      tutorial.handContainer.parent.toFront(tutorial.handContainer);
    }

    t.buttonMode = true;
    t.interactive = true;
    t.on("pointerdown", t.onPointerDown);
    t.on("pointermove", t.onPointerMove);
    t.on("pointerup", t.onPointerUp);
    t.rotation = -t.parent.rotation;
    return t;
  }

  gameLogic.moveSelection = function (direction) {
    if (gameLogic.gameOver || gameLogic.shifting) {
      return;
    }

    gameLogic.hideSelectionCircle(false);

    var dir = _toConsumableArray(direction);

    if (gameLogic.selectionCorrection < 0) {
      dir.reverse();
    }

    var oldI = gameScreen.selectionCircle.i;
    var oldJ = gameScreen.selectionCircle.j;
    gameScreen.selectionCircle.i += dir[0] * gameLogic.selectionCorrection;
    gameScreen.selectionCircle.i = Math.min(Math.max(gameScreen.selectionCircle.i, 0), gameLogic.m - 1);
    gameScreen.selectionCircle.j += dir[1];
    gameScreen.selectionCircle.j = Math.min(Math.max(gameScreen.selectionCircle.j, 0), gameLogic.n - 1);

    if (gameLogic.selectedNumbers.length === 0) {
      var pos = gameScreen.getNumberPos(gameScreen.selectionCircle.i, gameScreen.selectionCircle.j);
      TweenMax.to(gameScreen.selectionCircle, 0.1, {
        pixi: {
          x: pos.x,
          y: pos.y
        },
        delay: 0,
        ease: Power2.easeInOut
      });
    } else {
      if (gameLogic.lock) {
        return;
      }

      var num = gameLogic.numbers[gameScreen.selectionCircle.i][gameScreen.selectionCircle.j];

      if (gameLogic.selectedNumbers[0].canCapture(num) && (gameLogic.selectedNumbers.length === 1 || gameLogic.selectedNumbers[0] === num)) {
        num.onPointerMove();
        var pos = gameScreen.getNumberPos(gameScreen.selectionCircle.i, gameScreen.selectionCircle.j);
        TweenMax.to(gameScreen.selectionCircle, 0.1, {
          pixi: {
            x: pos.x,
            y: pos.y
          },
          delay: 0,
          ease: Power2.easeInOut
        });
      } else {
        var posEnd = gameScreen.getNumberPos(gameScreen.selectionCircle.i, gameScreen.selectionCircle.j);
        gameScreen.selectionCircle.i = oldI;
        gameScreen.selectionCircle.j = oldJ;
        var posSt = gameScreen.getNumberPos(gameScreen.selectionCircle.i, gameScreen.selectionCircle.j);
        gameScreen.selectionCircle.position = posSt;
        TweenMax.to(gameScreen.selectionCircle, 0.1, {
          pixi: {
            x: posSt.x + (posEnd.x - posSt.x) * 0.2,
            y: posSt.y + (posEnd.y - posSt.y) * 0.2
          },
          delay: 0,
          repeat: 1,
          yoyo: true,
          ease: Power2.easeIn
        });
      }
    }
  };

  gameLogic.hideSelectionCircle = function (hide) {
    if (hide === gameScreen.selectionCircle.hidden) {
      return;
    }

    gameScreen.selectionCircle.hidden = hide;
    var newAlpha = 1;

    if (hide) {
      newAlpha = 0;
    }

    TweenMax.to(gameScreen.selectionCircle, 0.33, {
      pixi: {
        alpha: newAlpha
      },
      delay: 0,
      ease: Power2.easeOut
    });
  };

  gameLogic.selectNumber = function (obj) {
    if (gameLogic.lock || gameLogic.gameOver || gameLogic.shifting) {
      return;
    }

    var num = gameLogic.numbers[gameScreen.selectionCircle.i][gameScreen.selectionCircle.j];
    num.onPointerDown();
  };

  gameLogic.unselectNumber = function (obj) {
    if (gameLogic.lock || gameLogic.gameOver || gameLogic.shifting) {
      return;
    }

    var num = gameLogic.numbers[gameScreen.selectionCircle.i][gameScreen.selectionCircle.j];
    num.onPointerUp();
  };

  console.log("%c{mea \ncoda}", "background:#000;height:60px;padding:10px;font-size:15px;color:#fff", ""); //settings

  var APP;
  var imgRoot = "assets/images/";
  var sndRoot = "assets/sounds/";
  var fntRoot = "assets/fonts/";
  var gameLogoPath = null; //"loadingimg/gameLogo.png";

  var loadingBG_color = 0xdae3e9;
  var loadingLogo1_color = 0x111111;
  var loadingLogo2_color = 0xffffff;
  var fontsPercentage = 10;
  var soundsPercentage = 50;
  var imagesPercentage = 40;

  var onLoadingComplete = function onLoadingComplete() {
    transition.fadeToColor(gameScreen, 1, loadingBG_color, function () {
      loadingScreen["delete"]();
      setTimeout(gameScreen.showBgGlow, 250);
    });
    ads.gameplayStart();
  };

  var images = [{
    path: "atlas.json"
  }, {
    path: "glow.svg"
  } //    {
  //        path: "crazy-logo.png"
  //	},
  ];
  var sounds = [{
    path: "shake.mp3",
    name: "shake",
    volume: 1,
    loop: false
  }, {
    path: "win.mp3",
    name: "win",
    volume: 1,
    loop: false
  }, {
    path: "scoreCount.mp3",
    name: "scoreCount",
    volume: 0.1,
    loop: false
  }, {
    path: "selectGem.mp3",
    name: "selectGem",
    volume: 0.2,
    loop: false
  }, {
    path: "btnClick.mp3",
    name: "btnClick",
    volume: 1,
    loop: false
  }];

  for (var i = 0; i < 16; i++) {
    sounds.push({
      path: "explode" + (i + 1) + ".mp3",
      name: "match" + (i + 1),
      volume: 0.2,
      loop: false
    });
  }

  var fonts = [{
    path: "manrope-bold.otf",
    name: "manrope-bold"
  }, {
    path: "manrope-medium.otf",
    name: "manrope-medium"
  }];
  var loadingScreen = {};
  var loadingBG_sprite, screen_container, loadingProgress, lastProgress, loading_container, loadingBar_sprite, loadingBarFrame_sprite, loadingLogo1_sprite, loadingLogo2_sprite;
  var loadingCompleted = false; // MODERNIZER CHECK FOR WEBSOCKET AND CANVAS SUPPORT ********* ********* ********* *********
  //if (!window.WebSocket) {
  //    console.log("This game is not optimized for this browser. Please install Google Chrome.");
  //
  //}

  function isCanvasSupported() {
    var elem = document.createElement("canvas");
    return !!(elem.getContext && elem.getContext("2d"));
  }

  if (!isCanvasSupported()) {
    console.log("This game is not optimized for this browser. Please install Google Chrome."); // SAMO PRIKAZATI POPUP
  } // DPI SETTINGS ********* ********* ********* *********


  var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  var dpr = Number(window.devicePixelRatio); //
  // GENERATE CANVAS GAME **************************************

  if (gameLogoPath) {
    PIXI.loader.add(gameLogoPath);
    PIXI.loader.once("complete", generateCanvas);
    PIXI.loader.load();
  } else {
    setTimeout(generateCanvas, 10);
  } //generateCanvas();


  function generateCanvas() {
    // SETUP CANVAS
    PIXI.loader.reset();
    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;
    APP = new PIXI.Application(window.innerWidth, window.innerHeight, {
      resolution: dpr,
      transparent: false,
      autoResize: true,
      legacy: true,
      clearBeforeRender: true,
      backgroundColor: 0x000000,
      antialias: true,
      forceCanvas: false
    });
    APP.renderer.plugins.interaction.moveWhenInside = true;
    $("#game").append(APP.view);

    if (APP.renderer instanceof PIXI.CanvasRenderer) {
      gameLogoPath = "";
    } else {}

    setRatioScale();
    screen_container = new Container(APP.stage);
    loadingScreen.root = new Container(screen_container);
    transition.setScreen(loadingScreen);
    loadAssets(images, sounds, fonts);
  }

  function loadAssets(images, sounds, fonts) {
    ads.gameLoadingStart();
    loadingProgress = 0;
    lastProgress = 0;
    loadingScreen.draw();
    resize(); //images

    if (images.length > 0) {
      for (var i = 0; i < images.length; i++) {
        PIXI.loader.add(imgRoot + images[i].path);
      }

      PIXI.loader.on("progress", onImageLoadProgress);
      PIXI.loader.load();
    } else {
      loadingProgress += imagesPercentage;
      onLoadProgress();
    } //sounds


    if (sounds.length > 0) {
      for (var i = 0; i < sounds.length; i++) {
        allSounds[sounds[i].name] = new Howl({
          src: sndRoot + sounds[i].path,
          loop: sounds[i].loop || false
        });
        allSounds[sounds[i].name].volume(sounds[i].volume || 1);
        allSounds[sounds[i].name].on("load", onSoundLoaded);
      }
    } else {
      loadingProgress += soundsPercentage;
      onLoadProgress();
    } //fonts


    if (fonts.length > 0) {
      //var fontLoader = new type.Loader();
      for (var i = 0; i < fonts.length; i++) {
        //fontLoader.add(fonts[i].name, fntRoot + fonts[i].path);
        var fontLoader = new FontFaceObserver(fonts[i].name);
        fontLoader.load().then(onFontsLoaded)["catch"](onFontsLoaded);
      } //fontLoader.once('loadComplete', onFontsLoaded);
      //fontLoader.load();

    } else {
      loadingProgress += fontsPercentage;
      onLoadProgress();
    }
  }

  loadingScreen.draw = function () {
    //bg
    loadingBG_sprite = new WhiteRectangle(loadingScreen.root, [APP.screen.width, APP.screen.height], loadingBG_color);
    loadingBG_sprite.anchor.set(0); // loadingScreen.dust = new Dust(
    //   loadingScreen.root,
    //   1,
    //   20,
    //   [0xffffff, 0xffff00, 0xff00ff, 0x00ffff],
    //   1
    // );
    // loadingScreen.dust.alpha = 1;

    loadingScreen.circle = new Circle(loadingScreen.root, Math.min(APP.screen.width, APP.screen.height) / 4);
    loadingScreen.circle.tint = loadingBG_color;
    loading_container = new Container(loadingScreen.root);
    loading_container.y = 0;
    loading_container.tween = TweenMax.to(loading_container, 1, {
      pixi: {
        y: 0
      },
      ease: Power1.easeInOut,
      repeat: -1,
      yoyo: true
    });
    loadingScreen.playContainer = new Container(loadingScreen.root); //progress bar

    if (!gameLogoPath) {
      loadingScreen.circle.visible = false;
      loadingBarFrame_sprite = new Rectangle(loading_container, [500, 20], [4, 0xffffff, 1], [0x000000, 0]);
      loadingBarFrame_sprite.tint = loadingLogo2_color;
      loadingBar_sprite = new WhiteRectangle(loading_container, [loadingBarFrame_sprite.width / 100, loadingBarFrame_sprite.height], loadingLogo2_color);
      loadingBar_sprite.anchor.set(0, 0.5);
    } //game logo
    else {
        loadingLogo1_sprite = new Sprite(loading_container, gameLogoPath);
        loadingLogo1_sprite.tint = loadingLogo1_color;
        loadingLogo1_sprite.position.set(APP.screen.width * 0.5, APP.screen.height * 0.33);
        loadingLogo2_sprite = new Sprite(loading_container, gameLogoPath);
        loadingLogo2_sprite.tint = loadingLogo2_color;
        loadingLogo2_sprite.position.set(APP.screen.width * 0.5, APP.screen.height * 0.33);
        loadingBar_sprite = new WhiteRectangle(loading_container, [loadingLogo1_sprite.width / 100, loadingLogo1_sprite.height]);
        loadingBar_sprite.anchor.set(0);
        loadingBar_sprite.position.set(loadingLogo1_sprite.x - loadingLogo1_sprite.width * 0.5, loadingLogo1_sprite.y - loadingLogo1_sprite.height * 0.5);
        loadingLogo2_sprite.mask = loadingBar_sprite;
      }

    loadingScreen.isDrawn = true;
    loadingScreen.resize();
  };

  function updateProgressBar(duration) {
    if (!gameLogoPath) {
      TweenMax.to(loadingBar_sprite, duration || 0.3, {
        pixi: {
          width: loadingBarFrame_sprite.width * loadingProgress / 100
        },
        ease: Power1.easeOut
      });
    } else {
      TweenMax.to(loadingBar_sprite, duration || 0.3, {
        pixi: {
          width: loadingLogo2_sprite.width * loadingProgress / 100
        },
        ease: Power1.easeOut
      });
    }
  }

  function removeProgressBar() {
    if (!gameLogoPath) {
      loadingBarFrame_sprite.visible = false;
      TweenMax.to(loadingBar_sprite, 0.2, {
        pixi: {
          height: 0
        },
        ease: Power1.easeIn,
        onComplete: function onComplete() {
          onLoadingComplete();
          setTimeout(function () {
            loading_container.tween.kill();
          }, 500);
        }
      });
    } else {
      TweenMax.to(loadingLogo1_sprite, 0.5, {
        pixi: {
          alpha: 0
        }
      });
      TweenMax.to(loadingScreen.circle, 0.5, {
        pixi: {
          alpha: 0
        },
        delay: 1
      });
      loadingLogo2_sprite.mask.visible = false;
      loadingLogo2_sprite.mask.visible = false;
      loadingLogo2_sprite.mask = null;
      TweenMax.to(loadingLogo2_sprite, 1, {
        pixi: {
          alpha: 0
        },
        delay: 2,
        onComplete: function onComplete() {
          setTimeout(function () {
            loading_container.tween.kill();
          }, 500);

          if (!ads.showAdOnLoad) {
            onLoadingComplete();
          } else {
            loadingScreen.playBtn = new Button(loadingScreen.playContainer, "", "play.png", function () {
              setTimeout(onLoadingComplete, 1000);
              loadingScreen.playBtn.interactive = false;
              ads.showAd();
              TweenMax.to(loadingScreen.playBtn, 0.5, {
                pixi: {
                  scale: 0.5,
                  alpha: 0
                },
                ease: Back.easeIn
              });
            }, LOADING_BUTTON);
            loadingScreen.playBtn.img.setTransform(15, 0);
            loadingScreen.playBtn.scale.set(0.5);
            loadingScreen.playBtn.alpha = 0;
            TweenMax.to(loadingScreen.playBtn, 0.5, {
              pixi: {
                scale: 1,
                alpha: 1
              },
              ease: Back.easeOut
            });
          }
        }
      });
    }
  }

  loadingScreen.resize = function () {
    if (!loadingScreen.isDrawn) {
      return;
    }

    if (!loadingScreen.root.visible) {
      return;
    } //bg


    loadingBG_sprite.width = APP.screen.width;
    loadingBG_sprite.height = APP.screen.height;
    loadingScreen.circle.width = Math.min(APP.screen.width, APP.screen.height) / 2;
    loadingScreen.circle.height = Math.min(APP.screen.width, APP.screen.height) / 2;
    loadingScreen.circle.setTransform(APP.screen.width / 2, APP.screen.height / 2);
    loadingScreen.playContainer.setTransform(APP.screen.width / 2, APP.screen.height / 2, ratio_scale, ratio_scale); //progress bar

    if (!gameLogoPath) {
      loadingBarFrame_sprite.scale.set(ratio_scale);
      loadingBarFrame_sprite.position.set(APP.screen.width * 0.5, APP.screen.height * 0.5);
      loadingBar_sprite.height = loadingBarFrame_sprite.height;
      loadingBar_sprite.position.set(loadingBarFrame_sprite.x - loadingBarFrame_sprite.width * 0.5, loadingBarFrame_sprite.y);
      updateProgressBar(0.01);
    } //game logo
    else {
        var scaleW = Math.min(0.5, APP.screen.height * 0.5 / APP.screen.width);

        if (APP.screen.width < APP.screen.height) {
          scaleW = 0.75;
        } //        loadingLogo1_sprite.height *= (APP.screen.width * scaleW / loadingLogo1_sprite.width);
        //        loadingLogo1_sprite.width = APP.screen.width * scaleW;
        //        loadingLogo1_sprite.position.set(APP.screen.width * 0.5, APP.screen.height * 0.5);


        loadingLogo1_sprite.setTransform(APP.screen.width * 0.5, APP.screen.height * 0.5, ratio_scale, ratio_scale);
        loadingLogo2_sprite.height = loadingLogo1_sprite.height;
        loadingLogo2_sprite.width = loadingLogo1_sprite.width;
        loadingLogo2_sprite.position.set(loadingLogo1_sprite.x, loadingLogo1_sprite.y);
        loadingBar_sprite.height = loadingLogo1_sprite.height;
        loadingBar_sprite.width = loadingLogo1_sprite.width;
        loadingBar_sprite.position.set(loadingLogo1_sprite.x - loadingLogo1_sprite.width * 0.5, loadingLogo1_sprite.y - loadingLogo1_sprite.height * 0.5);
        updateProgressBar(0.01); //loadingLogo1_sprite.height *= 0.995;
        //loadingLogo1_sprite.width *= 0.995;
        //        //center
        //        var totalHeight = (loadingBarFrame_sprite.y - loadingBarFrame_sprite.height * 0.5) - (loadingLogo_sprite.y - loadingLogo_sprite.height * 0.5);
        //        var diff = (loadingBarFrame_sprite.y - loadingBarFrame_sprite.height * 0.5) - (APP.screen.height * 0.5 + totalHeight * 0.5);
        //        loadingBarFrame_sprite.y -= diff;
        //        loadingBar_sprite.y -= diff;
        //        loadingLogo_sprite.y -= diff;
      }
  };

  resize_methods.push(loadingScreen.resize); //delete

  loadingScreen["delete"] = function () {
    loadingScreen.root["delete"]();
    loadingScreen.isDrawn = false;
  };

  function onLoadProgress() {
    if (loadingCompleted) return;
    updateProgressBar();
    ads.gameLoadingProgress(loadingProgress / 100);

    if (loadingProgress >= 99.99) {
      ads.gameLoadingFinished();
      loadingCompleted = true;
      setTimeout(function () {
        startGame();
        removeProgressBar();
      }, 250);
    }
  }

  function onImageLoadProgress(loader, resource) {
    loadingProgress += imagesPercentage * (loader.progress - lastProgress) / 100;
    lastProgress = loader.progress;
    onLoadProgress();
  }

  function onFontsLoaded(e) {
    console.log(e);
    loadingProgress += fontsPercentage;
    onLoadProgress();
  }

  function onSoundLoaded() {
    loadingProgress += soundsPercentage / sounds.length;
    onLoadProgress();
  }
})();
//# sourceMappingURL=main.min.js.map
